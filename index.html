<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PUBG Tracker Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 20px;
      margin: 0;
      box-sizing: border-box;
      background-color: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .controls {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .dropdown-container {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    select {
      padding: 10px 15px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
      background: white;
      cursor: pointer;
    }
    
    select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .content-section {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      overflow: hidden;
    }
    
    .section-header {
      background: #667eea;
      color: white;
      padding: 15px 20px;
      font-weight: bold;
      font-size: 18px;
    }
    
    .section-content {
      padding: 20px;
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .chart-container {
      background: white;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 15px;
      position: relative;
      height: 300px;
      min-height: 300px;
      width: 100%;
    }
    
    .chart-container canvas {
      width: 100% !important;
      height: 280px !important;
      max-height: 280px;
    }
    
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }
    
    .stat-title {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }
    
    .hidden {
      display: none !important;
    }
    
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
    
    .weapons-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .weapon-chart {
      height: 250px;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 10px;
    }

    .player-bio {
      text-align: center;
    }

    .player-bio h2 {
      color: #667eea;
      margin-bottom: 20px;
      font-size: 28px;
    }

    .bio-content {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      border-left: 4px solid #667eea;
    }

    .bio-content p {
      font-size: 18px;
      line-height: 1.6;
      color: #555;
      margin: 0;
      font-style: italic;
    }

    .bio-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .meme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .meme-card {
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .meme-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .meme-value {
      font-size: 24px;
      margin: 10px 0;
    }

    .meme-description {
      font-size: 14px;
      opacity: 0.9;
      font-style: italic;
    }

    .records-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .record-card {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .record-trophy {
      font-size: 30px;
      margin-bottom: 10px;
    }

    .record-title {
      font-size: 16px;
      margin-bottom: 10px;
      font-weight: bold;
    }

    .record-holder {
      font-size: 20px;
      margin: 10px 0;
      color: #ffd700;
    }

    .record-value {
      font-size: 24px;
      font-weight: bold;
      margin: 5px 0;
    }

    .record-date {
      font-size: 12px;
      color: #e0e0e0;
      margin-top: 8px;
      font-style: italic;
    }

    .special-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 5px;
    }

    .special-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .special-btn:hover {
      background: linear-gradient(135deg, #764ba2, #667eea);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .special-btn:active, .special-btn.active {
      background: linear-gradient(135deg, #5a67d8, #553c9a);
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üéÆ PUBG Performance Dashboard</h1>
    <p>Track your team's performance with detailed statistics and weapon analytics</p>
    <p><small id="lastUpdated">Loading sync information...</small></p>
  </div>
  
  <div id="knownBugs" class="content-section" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0;">
    <div class="section-header" style="color: #856404; font-size: 14px; margin-bottom: 5px;">‚ö†Ô∏è Known Issues</div>
    <div style="font-size: 12px; color: #856404;">
      <ul style="margin: 5px 0; padding-left: 20px;">
        <li><strong>Weapon Damage:</strong> Includes damage to wildlife (bears) and self/team damage from grenades/vehicles</li>
        <li><strong>Team Damage:</strong> Friendly fire and environmental damage is counted in statistics</li>
        <li><strong>Data Sync:</strong> Cache issues may show outdated match data - use hard refresh (Ctrl+Shift+R)</li>
      </ul>
      <small style="font-style: italic;">These will be addressed in future updates</small>
    </div>
  </div>
  
  <div class="controls">
    <div class="dropdown-container">
      <label><strong>Select Day:</strong></label>
      <select id="daySelect">
        <option value="">Choose a day...</option>
      </select>
      
      <label><strong>Team Filter:</strong></label>
      <select id="teamCompositionSelect">
        <option value="all">All Compositions</option>
        <option value="">Loading...</option>
      </select>
      
      <label><strong>Game Type:</strong></label>
      <select id="gameTypeSelect">
        <option value="all">All Types</option>
        <option value="normal">‚öîÔ∏è Normal</option>
        <option value="ranked">üèÜ Ranked</option>
        <option value="arcade">üé™ Arcade</option>
      </select>
      
      <label><strong>Team Size:</strong></label>
      <select id="teamSizeSelect">
        <option value="all">All Sizes</option>
        <option value="solo">üë§ Solo</option>
        <option value="duo">üë• Duo</option>
        <option value="squad">üë™ Squad</option>
      </select>
      
      <label><strong>Perspective:</strong></label>
      <select id="perspectiveSelect">
        <option value="all">All Perspectives</option>
        <option value="fpp">üëÅÔ∏è First Person (FPP)</option>
        <option value="tpp">üëÄ Third Person (TPP)</option>
      </select>
      
      <label><strong>Select Match:</strong></label>
      <select id="matchSelect" disabled>
        <option value="">Choose a match...</option>
      </select>
      
      <label><strong>Player BIO:</strong></label>
      <select id="bioSelect">
        <option value="">Choose a player...</option>
        <option value="Kilma9">Kilma9</option>
        <option value="Veru_13">Veru_13</option>
        <option value="Mar-0">Mar-0</option>
        <option value="Hyottokko">Hyottokko</option>
        <option value="Baron_Frajeris">Baron_Frajeris</option>
        <option value="codufus">codufus</option>
      </select>
      
      <label><strong>Special Sections:</strong></label>
      <div class="special-buttons">
        <button id="memesBtn" class="special-btn">ü§° Meme Dashboard</button>
        <button id="recordsBtn" class="special-btn">üèÜ Team Records</button>
        <button id="changelogBtn" class="special-btn">üìã Changelog</button>
      </div>
    </div>
  </div>
  
  <div id="dayContent" class="content-section hidden">
    <div class="section-header">Daily Summary</div>
    <div class="section-content">
      <div id="daySummary"></div>
      <div id="dayCharts"></div>
    </div>
  </div>
  
  <div id="matchContent" class="content-section hidden">
    <div class="section-header">Match Details</div>
    <div class="section-content">
      <div id="matchSummary"></div>
      <div id="matchCharts"></div>
    </div>
  </div>

  <div id="bioContent" class="content-section hidden">
    <div class="section-header">Player Biography</div>
    <div class="section-content">
      <div id="bioDetails"></div>
    </div>
  </div>

  <div id="memeContent" class="content-section hidden">
    <div class="section-header">ü§° Meme Dashboard - Hall of Fame</div>
    <div class="section-content">
      <div id="memeDetails"></div>
    </div>
  </div>

  <div id="recordsContent" class="content-section hidden">
    <div class="section-header">üèÜ Team Records & Achievements</div>
    <div class="section-content">
      <div id="recordsDetails"></div>
    </div>
  </div>

  <div id="changelogContent" class="content-section hidden">
    <div class="section-header">üìã Changelog</div>
    <div class="section-content">
      <div id="changelogDetails"></div>
    </div>
  </div>

  <script>
    let matchData = [];
    let currentCharts = [];
    let cachedRecords = null; // Cache for pre-calculated records

    // Utility function to clean weapon names
    function cleanWeaponName(weapon) {
      return weapon.replace(/^(Weap |Proj )/i, '').replace(/_/g, ' ').trim();
    }

    // Utility function to destroy existing charts
    function destroyCharts() {
      currentCharts.forEach(chart => {
        if (chart && typeof chart.destroy === 'function') {
          chart.destroy();
        }
      });
      currentCharts = [];
    }

    // Load and process data
    // Add cache-busting parameter to force fresh data loading
    const timestamp = new Date().getTime();
    fetch(`/data.json?v=${timestamp}`)
      .then(res => res.json())
      .then(async (data) => {
        matchData = data;
        
        // Pre-calculate records automatically on every data load
        console.log('üìä Pre-calculating team records...');
        cachedRecords = calculateTeamRecords();
        console.log('‚úÖ Records calculated and cached');
        
        populateDayDropdown();
        populateTeamCompositions();
        await updateSyncInfo(data);
      })
      .catch(error => {
        console.error('Error loading data:', error);
        document.getElementById('lastUpdated').textContent = 'Error loading data - check connection';
      });

    // Update sync information with Prague time
    async function updateSyncInfo(data) {
      try {
        // Try to fetch the actual sync timestamp first
        let actualSyncTime = null;
        try {
          const syncResponse = await fetch(`/last-sync.json?v=${new Date().getTime()}`);
          if (syncResponse.ok) {
            const syncData = await syncResponse.json();
            actualSyncTime = syncData.pragueTime;
          }
        } catch (syncError) {
          console.log('No sync timestamp file found, using fallback');
        }

        // Find the most recent match
        let latestMatch = null;
        let latestTime = 0;
        
        data.forEach(match => {
          const matchTime = new Date(match.date).getTime();
          if (matchTime > latestTime) {
            latestTime = matchTime;
            latestMatch = match;
          }
        });

        let syncInfo;
        if (actualSyncTime) {
          syncInfo = `Data collected: ${actualSyncTime} (Prague) - ${data.length} matches`;
        } else {
          // Fallback: show page load time
          const pageLoadTime = new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Prague',
            day: 'numeric',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
          }).format(new Date());
          syncInfo = `Page loaded: ${pageLoadTime} (Prague) - ${data.length} matches`;
        }
        
        if (latestMatch) {
          const lastMatchPragueTime = new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Prague',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          }).format(new Date(latestMatch.date));
          
          syncInfo += ` | Latest match: ${lastMatchPragueTime} (Prague)`;
        }

        document.getElementById('lastUpdated').textContent = syncInfo;
      } catch (error) {
        console.error('Error updating sync info:', error);
        document.getElementById('lastUpdated').textContent = `Fresh data with ${data.length} matches!`;
      }
    }

    function populateDayDropdown() {
      const daySelect = document.getElementById('daySelect');
      const days = [...new Set(matchData.map(match => match.date.split('T')[0]))].sort().reverse();
      
      days.forEach(day => {
        const option = document.createElement('option');
        option.value = day;
        option.textContent = day;
        daySelect.appendChild(option);
      });
    }

    function populateMatchDropdown(selectedDay) {
      const matchSelect = document.getElementById('matchSelect');
      matchSelect.innerHTML = '<option value="">Choose a match...</option>';
      
      const teamComposition = document.getElementById('teamCompositionSelect').value;
      const gameType = document.getElementById('gameTypeSelect').value;
      const teamSize = document.getElementById('teamSizeSelect').value;
      const perspective = document.getElementById('perspectiveSelect').value;
      const dayMatches = getFilteredMatches(selectedDay, teamComposition, gameType, teamSize, perspective);
      
      dayMatches.forEach((match, index) => {
        const option = document.createElement('option');
        option.value = index.toString();
        const time = new Date(match.date).toLocaleTimeString();
        const teamNames = match.team.map(p => p.name).join(', ');
        
        // Add game mode info if available
        let modeInfo = '';
        if (match.gameType && match.teamSize && match.perspective) {
          const typeIcon = match.gameType === 'ranked' ? 'üèÜ' : match.gameType === 'arcade' ? 'üé™' : '‚öîÔ∏è';
          const sizeText = match.teamSize.charAt(0).toUpperCase() + match.teamSize.slice(1);
          modeInfo = ` [${typeIcon} ${sizeText} ${match.perspective.toUpperCase()}]`;
        }
        
        option.textContent = `Match ${index + 1} (${time})${modeInfo} - ${teamNames}`;
        matchSelect.appendChild(option);
      });
      
      matchSelect.disabled = dayMatches.length === 0;
    }

    // Get unique team compositions
    function getTeamCompositions() {
      const compositions = new Set();
      matchData.forEach(match => {
        const teamNames = match.team.map(player => player.name).sort().join(', ');
        compositions.add(teamNames);
      });
      return Array.from(compositions).sort();
    }

    // Populate team composition dropdown
    function populateTeamCompositions() {
      const teamSelect = document.getElementById('teamCompositionSelect');
      teamSelect.innerHTML = '<option value="all">All Compositions</option>';
      
      const compositions = getTeamCompositions();
      compositions.forEach(composition => {
        const option = document.createElement('option');
        option.value = composition;
        option.textContent = `${composition} (${getCompositionMatchCount(composition)} matches)`;
        teamSelect.appendChild(option);
      });
    }

    // Get match count for a specific team composition
    function getCompositionMatchCount(composition) {
      return matchData.filter(match => {
        const teamNames = match.team.map(player => player.name).sort().join(', ');
        return teamNames === composition;
      }).length;
    }

    // Filter matches by team composition and game modes
    function getFilteredMatches(day, teamComposition = 'all', gameType = 'all', teamSize = 'all', perspective = 'all') {
      let filtered = matchData.filter(match => match.date.split('T')[0] === day);
      
      // Filter by team composition
      if (teamComposition !== 'all') {
        filtered = filtered.filter(match => {
          const teamNames = match.team.map(player => player.name).sort().join(', ');
          return teamNames === teamComposition;
        });
      }
      
      // Filter by game type (normal/ranked/arcade)
      if (gameType !== 'all') {
        filtered = filtered.filter(match => {
          if (!match.gameType) return false; // Skip matches without gameType data
          return match.gameType === gameType;
        });
      }
      
      // Filter by team size (solo/duo/squad)
      if (teamSize !== 'all') {
        filtered = filtered.filter(match => {
          if (!match.teamSize) return false; // Skip matches without teamSize data
          return match.teamSize === teamSize;
        });
      }
      
      // Filter by perspective (fpp/tpp)
      if (perspective !== 'all') {
        filtered = filtered.filter(match => {
          if (!match.perspective) return false; // Skip matches without perspective data
          return match.perspective === perspective;
        });
      }
      
      return filtered;
    }

    function showDaySummary(day) {
      destroyCharts();
      const teamComposition = document.getElementById('teamCompositionSelect').value;
      const gameType = document.getElementById('gameTypeSelect').value;
      const teamSize = document.getElementById('teamSizeSelect').value;
      const perspective = document.getElementById('perspectiveSelect').value;
      const dayMatches = getFilteredMatches(day, teamComposition, gameType, teamSize, perspective);
      
      console.log('Processing day:', day, 'with', dayMatches.length, 'matches');
      console.log('Filters:', { teamComposition, gameType, teamSize, perspective });
      
      if (dayMatches.length === 0) {
        document.getElementById('daySummary').innerHTML = `
          <div class="stat-card">
            <div class="stat-title">No Matches Found</div>
            <div class="stat-value">No matches for selected team composition on ${day}</div>
          </div>
        `;
        document.getElementById('dayContent').classList.remove('hidden');
        return;
      }
      
      // Calculate daily aggregated stats
      const playerStats = {};
      dayMatches.forEach(match => {
        match.team.forEach(player => {
          if (!playerStats[player.name]) {
            playerStats[player.name] = {
              kills: 0, damage: 0, headshots: 0, assists: 0, 
              boosts: 0, heals: 0, revives: 0, matches: 0,
              weapons: {}, weaponDamage: {}
            };
          }
          const stats = playerStats[player.name];
          stats.kills += player.kills || 0;
          stats.damage += player.damage || 0;
          stats.headshots += player.headshots || 0;
          stats.assists += player.assists || 0;
          stats.boosts += player.boosts || 0;
          stats.heals += player.heals || 0;
          stats.revives += player.revives || 0;
          stats.matches++;
          
          // Aggregate weapon damage
          Object.entries(player.weaponDamage || {}).forEach(([weapon, damage]) => {
            if (weapon.includes('Player') || weapon.includes('Effect')) return;
            const cleanName = cleanWeaponName(weapon);
            if (!stats.weaponDamage[cleanName]) stats.weaponDamage[cleanName] = 0;
            stats.weaponDamage[cleanName] += damage;
          });
        });
      });

      console.log('Player stats calculated:', Object.keys(playerStats).length, 'players');

      // Display summary stats
      const summaryHtml = `
        <div class="stats-summary">
          <div class="stat-card">
            <div class="stat-title">Total Matches</div>
            <div class="stat-value">${dayMatches.length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Players</div>
            <div class="stat-value">${Object.keys(playerStats).length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Total Kills</div>
            <div class="stat-value">${Object.values(playerStats).reduce((sum, p) => sum + p.kills, 0)}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Total Damage</div>
            <div class="stat-value">${Math.round(Object.values(playerStats).reduce((sum, p) => sum + p.damage, 0)).toLocaleString()}</div>
          </div>
        </div>
      `;
      
      document.getElementById('daySummary').innerHTML = summaryHtml;

      // Create charts
      const chartsHtml = `
        <div class="charts-grid">
          <div class="chart-container"><canvas id="dayKillsChart"></canvas></div>
          <div class="chart-container"><canvas id="dayDamageChart"></canvas></div>
          <div class="chart-container"><canvas id="dayHeadshotsChart"></canvas></div>
          <div class="chart-container"><canvas id="dayAssistsChart"></canvas></div>
        </div>
        <div id="weaponCharts" class="weapons-grid"></div>
      `;
      
      document.getElementById('dayCharts').innerHTML = chartsHtml;

      // Show the day content first
      document.getElementById('dayContent').classList.remove('hidden');

      // Use setTimeout to ensure DOM is ready before creating charts
      setTimeout(() => {
        const players = Object.keys(playerStats);
        console.log('Creating charts for players:', players);
        
        if (players.length === 0) {
          console.error('No players found for charts');
          return;
        }

        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { 
            legend: { display: false },
            title: { display: true }
          },
          scales: { 
            y: { beginAtZero: true }
          },
          animation: false // Disable animation for faster rendering
        };

        // Check if canvas elements exist before creating charts
        const killsCanvas = document.getElementById('dayKillsChart');
        const damageCanvas = document.getElementById('dayDamageChart');
        const headshotsCanvas = document.getElementById('dayHeadshotsChart');
        const assistsCanvas = document.getElementById('dayAssistsChart');

        console.log('Canvas elements found:', {
          kills: !!killsCanvas,
          damage: !!damageCanvas,
          headshots: !!headshotsCanvas,
          assists: !!assistsCanvas
        });

        if (!killsCanvas || !damageCanvas || !headshotsCanvas || !assistsCanvas) {
          console.error('Canvas elements not found');
          return;
        }

        // Performance charts
        try {
          console.log('Creating kills chart...');
          const killsChart = new Chart(killsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Kills',
                data: players.map(p => playerStats[p].kills),
                backgroundColor: '#ff6b6b',
                borderColor: '#ff5252',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Kills' } 
              } 
            }
          });
          currentCharts.push(killsChart);
          console.log('Kills chart created successfully');

          console.log('Creating damage chart...');
          const damageChart = new Chart(damageCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Damage',
                data: players.map(p => Math.round(playerStats[p].damage)),
                backgroundColor: '#4ecdc4',
                borderColor: '#26d0ce',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Damage' } 
              } 
            }
          });
          currentCharts.push(damageChart);
          console.log('Damage chart created successfully');

          console.log('Creating headshots chart...');
          const headshotsChart = new Chart(headshotsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Headshots',
                data: players.map(p => playerStats[p].headshots),
                backgroundColor: '#45b7d1',
                borderColor: '#3742fa',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Headshots' } 
              } 
            }
          });
          currentCharts.push(headshotsChart);
          console.log('Headshots chart created successfully');

          console.log('Creating assists chart...');
          const assistsChart = new Chart(assistsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Assists',
                data: players.map(p => playerStats[p].assists),
                backgroundColor: '#f7b731',
                borderColor: '#fa8231',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Assists' } 
              } 
            }
          });
          currentCharts.push(assistsChart);
          console.log('Assists chart created successfully');

          console.log('All main charts created successfully. Total charts:', currentCharts.length);
        } catch (error) {
          console.error('Error creating main charts:', error);
        }

        // Weapon charts for each player
        const weaponChartsContainer = document.getElementById('weaponCharts');
        if (weaponChartsContainer) {
          weaponChartsContainer.innerHTML = '';
          
          players.forEach(player => {
            const weapons = Object.entries(playerStats[player].weaponDamage)
              .filter(([weapon, damage]) => damage > 0)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 10); // Top 10 weapons
            
            if (weapons.length > 0) {
              const chartDiv = document.createElement('div');
              chartDiv.className = 'weapon-chart';
              const cleanPlayerId = player.replace(/[^a-zA-Z0-9]/g, '_');
              chartDiv.innerHTML = `<canvas id="weapon-${cleanPlayerId}"></canvas>`;
              weaponChartsContainer.appendChild(chartDiv);
              
              console.log(`Creating weapon chart for ${player} with ${weapons.length} weapons`);
              
              // Use another setTimeout for weapon charts
              setTimeout(() => {
                const weaponCanvas = document.getElementById(`weapon-${cleanPlayerId}`);
                if (weaponCanvas) {
                  try {
                    const weaponChart = new Chart(weaponCanvas, {
                      type: 'doughnut',
                      data: {
                        labels: weapons.map(([weapon]) => weapon),
                        datasets: [{
                          data: weapons.map(([_, damage]) => Math.round(damage)),
                          backgroundColor: [
                            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                            '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                          ]
                        }]
                      },
                      options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                          title: { display: true, text: `${player} - Weapon Damage` },
                          legend: { position: 'bottom', labels: { boxWidth: 12, fontSize: 10 } }
                        }
                      }
                    });
                    currentCharts.push(weaponChart);
                    console.log(`Weapon chart created for ${player}`);
                  } catch (error) {
                    console.error(`Error creating weapon chart for ${player}:`, error);
                  }
                } else {
                  console.error(`Weapon canvas not found for ${player}`);
                }
              }, 200);
            }
          });
        }

        // Final check and debug info
        setTimeout(() => {
          console.log('Final chart count:', currentCharts.length);
          console.log('Chart containers visible:', {
            dayContent: !document.getElementById('dayContent').classList.contains('hidden'),
            chartsGrid: !!document.querySelector('.charts-grid'),
            chartContainers: document.querySelectorAll('.chart-container').length
          });
        }, 500);
      }, 250); // Increased timeout to give more time for DOM rendering
    }

    function showMatchDetails(dayMatches, matchIndex) {
      destroyCharts(); // Only destroy charts, keep day summary visible
      const match = dayMatches[matchIndex];
      
      console.log('Showing match details for match', matchIndex);
      
      // Match summary
      const summaryHtml = `
        <div class="stats-summary">
          <div class="stat-card">
            <div class="stat-title">Match Time</div>
            <div class="stat-value">${new Date(match.date).toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Size</div>
            <div class="stat-value">${match.team.length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Kills</div>
            <div class="stat-value">${match.team.reduce((sum, p) => sum + (p.kills || 0), 0)}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Damage</div>
            <div class="stat-value">${Math.round(match.team.reduce((sum, p) => sum + (p.damage || 0), 0)).toLocaleString()}</div>
          </div>
        </div>
      `;
      
      document.getElementById('matchSummary').innerHTML = summaryHtml;

      // Match charts
      const chartsHtml = `
        <div class="charts-grid">
          <div class="chart-container"><canvas id="matchKillsChart"></canvas></div>
          <div class="chart-container"><canvas id="matchDamageChart"></canvas></div>
          <div class="chart-container"><canvas id="matchHeadshotsChart"></canvas></div>
          <div class="chart-container"><canvas id="matchHealsChart"></canvas></div>
        </div>
        <div id="matchWeaponCharts" class="weapons-grid"></div>
      `;
      
      document.getElementById('matchCharts').innerHTML = chartsHtml;

      // Show match content
      document.getElementById('matchContent').classList.remove('hidden');

      // Create match charts with delay
      setTimeout(() => {
        const players = match.team.map(p => p.name);
        console.log('Creating match charts for players:', players);
        
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { 
            legend: { display: false },
            title: { display: true }
          },
          scales: { 
            y: { beginAtZero: true }
          },
          animation: false
        };

        // Check canvas elements
        const killsCanvas = document.getElementById('matchKillsChart');
        const damageCanvas = document.getElementById('matchDamageChart');
        const headshotsCanvas = document.getElementById('matchHeadshotsChart');
        const healsCanvas = document.getElementById('matchHealsChart');

        console.log('Match canvas elements found:', {
          kills: !!killsCanvas,
          damage: !!damageCanvas,
          headshots: !!headshotsCanvas,
          heals: !!healsCanvas
        });

        if (!killsCanvas || !damageCanvas || !headshotsCanvas || !healsCanvas) {
          console.error('Match canvas elements not found');
          return;
        }

        try {
          // Performance charts
          const killsChart = new Chart(killsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => p.kills || 0),
                backgroundColor: '#ff6b6b',
                borderColor: '#ff5252',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Kills' } } }
          });
          currentCharts.push(killsChart);

          const damageChart = new Chart(damageCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => Math.round(p.damage || 0)),
                backgroundColor: '#4ecdc4',
                borderColor: '#26d0ce',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Damage' } } }
          });
          currentCharts.push(damageChart);

          const headshotsChart = new Chart(headshotsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => p.headshots || 0),
                backgroundColor: '#45b7d1',
                borderColor: '#3742fa',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Headshots' } } }
          });
          currentCharts.push(headshotsChart);

          const healsChart = new Chart(healsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => (p.heals || 0) + (p.boosts || 0)),
                backgroundColor: '#26de81',
                borderColor: '#20bf6b',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Heals + Boosts' } } }
          });
          currentCharts.push(healsChart);

          console.log('Match charts created successfully');
        } catch (error) {
          console.error('Error creating match charts:', error);
        }

        // Individual weapon charts for each player
        const weaponChartsContainer = document.getElementById('matchWeaponCharts');
        if (weaponChartsContainer) {
          weaponChartsContainer.innerHTML = '';
          
          match.team.forEach(player => {
            const weapons = Object.entries(player.weaponDamage || {})
              .filter(([weapon, damage]) => damage > 0 && !weapon.includes('Player') && !weapon.includes('Effect'))
              .map(([weapon, damage]) => [cleanWeaponName(weapon), damage])
              .sort((a, b) => b[1] - a[1]);
            
            if (weapons.length > 0) {
              const chartDiv = document.createElement('div');
              chartDiv.className = 'weapon-chart';
              const cleanPlayerId = player.name.replace(/[^a-zA-Z0-9]/g, '_');
              chartDiv.innerHTML = `<canvas id="match-weapon-${cleanPlayerId}"></canvas>`;
              weaponChartsContainer.appendChild(chartDiv);
              
              setTimeout(() => {
                const weaponCanvas = document.getElementById(`match-weapon-${cleanPlayerId}`);
                if (weaponCanvas) {
                  try {
                    const weaponChart = new Chart(weaponCanvas, {
                      type: 'doughnut',
                      data: {
                        labels: weapons.map(([weapon]) => weapon),
                        datasets: [{
                          data: weapons.map(([_, damage]) => Math.round(damage)),
                          backgroundColor: [
                            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                            '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                          ]
                        }]
                      },
                      options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                          title: { display: true, text: `${player.name} - Weapon Damage` },
                          legend: { position: 'bottom', labels: { boxWidth: 12, fontSize: 10 } }
                        }
                      }
                    });
                    currentCharts.push(weaponChart);
                  } catch (error) {
                    console.error(`Error creating match weapon chart for ${player.name}:`, error);
                  }
                }
              }, 200);
            }
          });
        }
      }, 250);
    }

    // Event listeners
    document.getElementById('daySelect').addEventListener('change', function() {
      const selectedDay = this.value;
      
      console.log('Day selected:', selectedDay);
      
      if (selectedDay) {
        // Show main dashboard when day is selected
        toggleMainDashboard(false);
        
        // Reset bio and special dropdowns
        document.getElementById('bioSelect').value = '';
        resetSpecialButtons();
        document.getElementById('bioContent').classList.add('hidden');
        document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
        
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        // Don't hide matchContent, just reset the match dropdown
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      } else {
        document.getElementById('matchSelect').disabled = true;
        document.getElementById('matchSelect').value = '';
        document.getElementById('dayContent').classList.add('hidden');
        document.getElementById('matchContent').classList.add('hidden');
        destroyCharts();
      }
    });

    // Team composition filter event listener
    document.getElementById('teamCompositionSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        // Reset match selection when composition changes
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    // Game type filter event listener
    document.getElementById('gameTypeSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    // Team size filter event listener
    document.getElementById('teamSizeSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    // Perspective filter event listener
    document.getElementById('perspectiveSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    document.getElementById('matchSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      const matchIndex = parseInt(this.value);
      
      console.log('Match selected:', matchIndex, 'for day:', selectedDay);
      
      if (!isNaN(matchIndex) && selectedDay) {
        // Ensure main dashboard is visible when match is selected
        toggleMainDashboard(false);
        
        // Reset bio and special dropdowns
        document.getElementById('bioSelect').value = '';
        resetSpecialButtons();
        document.getElementById('bioContent').classList.add('hidden');
        document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
        
        const teamComposition = document.getElementById('teamCompositionSelect').value;
        const dayMatches = getFilteredMatches(selectedDay, teamComposition);
        showMatchDetails(dayMatches, matchIndex);
        // Hide day summary when match is selected
        document.getElementById('dayContent').classList.add('hidden');
      } else {
        document.getElementById('matchContent').classList.add('hidden');
        // Show day summary again when no match is selected
        if (selectedDay) {
          document.getElementById('dayContent').classList.remove('hidden');
        }
        // Re-destroy only match charts, keep day charts
        const matchCharts = currentCharts.filter(chart => 
          chart.canvas && chart.canvas.id && chart.canvas.id.includes('match')
        );
        matchCharts.forEach(chart => {
          if (chart && typeof chart.destroy === 'function') {
            chart.destroy();
          }
        });
        currentCharts = currentCharts.filter(chart => 
          !(chart.canvas && chart.canvas.id && chart.canvas.id.includes('match'))
        );
      }
    });

    // Function to hide/show main dashboard sections
    function toggleMainDashboard(hide = false) {
      const mainSections = ['dayContent', 'matchContent'];
      const knownBugs = document.getElementById('knownBugs');
      
      if (hide) {
        // Hide main sections when Bio/Special is active
        mainSections.forEach(sectionId => {
          document.getElementById(sectionId).classList.add('hidden');
        });
        if (knownBugs) knownBugs.style.display = 'none';
      } else {
        // Show main sections when returning to normal mode
        mainSections.forEach(sectionId => {
          document.getElementById(sectionId).classList.remove('hidden');
        });
        if (knownBugs) knownBugs.style.display = 'block';
      }
    }

    // BIO dropdown event listener
    document.getElementById('bioSelect').addEventListener('change', function() {
      const selectedPlayer = this.value;
      
      console.log('Player BIO selected:', selectedPlayer);
      
      if (selectedPlayer) {
        // Hide main dashboard when showing bio
        toggleMainDashboard(true);
        showPlayerBio(selectedPlayer);
        
        // Reset other dropdowns
        resetSpecialButtons();
        document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
      } else {
        // Show main dashboard when no bio selected
        toggleMainDashboard(false);
        document.getElementById('bioContent').classList.add('hidden');
      }
    });

    // Helper function to reset special button states
    function resetSpecialButtons() {
      document.querySelectorAll('.special-btn').forEach(btn => {
        btn.classList.remove('active');
      });
    }

    // Helper function to hide all special sections
    function hideAllSpecialSections() {
      document.getElementById('memeContent').classList.add('hidden');
      document.getElementById('recordsContent').classList.add('hidden');
      document.getElementById('changelogContent').classList.add('hidden');
    }

    // Memes button event listener
    document.getElementById('memesBtn').addEventListener('click', function() {
      console.log('Memes button clicked');
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showMemesDashboard();
      
      // Reset bio dropdown
      document.getElementById('bioSelect').value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Records button event listener
    document.getElementById('recordsBtn').addEventListener('click', function() {
      console.log('Records button clicked');
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showTeamRecords();
      
      // Reset bio dropdown
      document.getElementById('bioSelect').value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Changelog button event listener
    document.getElementById('changelogBtn').addEventListener('click', function() {
      console.log('Changelog button clicked');
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showChangelog();
      
      // Reset bio dropdown
      document.getElementById('bioSelect').value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Function to show player bio
    function showPlayerBio(playerName) {
      const bioData = {
        'Kilma9': {
          description: 'Somehow crashes every vehicle! üöóüí• Maybe stick to ARs instead of SMGs and try DMRs over SRs - your teammates\' ears will thank you!',
          favoriteGun: 'Gliders',
          funnyNote: 'Driving instructor\'s worst nightmare'
        },
        'Veru_13': {
          description: 'The queen of all range engagements who dominates every distance! üëëüéØ AUG for close spraying, Mini14 for long-range sniping - true master of battlefield versatility!',
          favoriteGun: 'AUG & Mini14',
          funnyNote: 'Range? What range?'
        },
        'Mar-0': {
          description: 'The landing strategist who always picks the "perfect" spot... right between 5 enemy teams! ü™ÇüíÄ At least he has an AUG to fight his way out!',
          favoriteGun: 'AUG',
          funnyNote: 'Hot zone magnet'
        },
        'Hyottokko': {
          description: 'Son of ancient Greek gods with divine bloodline... too bad he forgot to bring those powers into PUBG! ‚ö°Ô∏èüèõÔ∏è The gods are still waiting for him to awaken!',
          favoriteGun: 'Kar98k',
          funnyNote: 'Dormant deity'
        },
        'Baron_Frajeris': {
          description: 'The legendary hoarder who carries zero ammo and no heals, but somehow has 200 mortar shells! üí£üéí "Need ammo?" - "Sorry, only explosives!"',
          favoriteGun: 'Mortars',
          funnyNote: 'Explosive logistics expert'
        },
        'codufus': {
          description: 'Bad mother father from the beautiful island of Corsica! üèùÔ∏èüòé Feels right at home on Paramo map - another volcanic island where he can spray enemies among familiar terrain and architecture!',
          favoriteGun: 'AUG',
          funnyNote: 'Volcanic island warrior'
        }
      };

      const player = bioData[playerName] || {
        description: 'Mysterious player with classified intel.',
        favoriteGun: 'Pan',
        funnyNote: 'Identity unknown'
      };

      const bioHtml = `
        <div class="player-bio">
          <h2>üéÆ ${playerName}</h2>
          <div class="bio-content">
            <p>${player.description}</p>
          </div>
          <div class="bio-stats">
            <div class="stat-card">
              <div class="stat-title">Favorite Gun</div>
              <div class="stat-value">üî´ ${player.favoriteGun}</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Status</div>
              <div class="stat-value">Active Player</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Specialty</div>
              <div class="stat-value">${player.funnyNote}</div>
            </div>
          </div>
        </div>
      `;

      document.getElementById('bioDetails').innerHTML = bioHtml;
      document.getElementById('bioContent').classList.remove('hidden');
    }

    // Function to show Memes Dashboard
    function showMemesDashboard() {
      const memeStats = calculateMemeStats();
      
      const memeHtml = `
        <div class="meme-grid">
          <div class="meme-card">
            <div class="meme-title">üöóüí• Vehicle Destruction Expert</div>
            <div class="meme-value">Kilma9</div>
            <div class="meme-description">"I swear the glider controls are different!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üéí Explosive Hoarder Award</div>
            <div class="meme-value">Baron_Frajeris</div>
            <div class="meme-description">"Need ammo? I have mortars!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">ü™Ç Hot Zone Magnet</div>
            <div class="meme-value">Mar-0</div>
            <div class="meme-description">"This looks like a quiet spot..." *5 teams land*</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">‚ö° Sleeping Deity</div>
            <div class="meme-value">Hyottokko</div>
            <div class="meme-description">"Gods don't need aim assist"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üëë Range Empress</div>
            <div class="meme-value">Veru_13</div>
            <div class="meme-description">"Distance is just a number"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üíä Most Likely to Need Revive</div>
            <div class="meme-value">${memeStats.mostRevives}</div>
            <div class="meme-description">"I was checking the map!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üî• Damage Dealer Supreme</div>
            <div class="meme-value">${memeStats.topDamager}</div>
            <div class="meme-description">Making enemies regret their life choices</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üéØ Kill Stealer Extraordinaire</div>
            <div class="meme-value">${memeStats.killStealer}</div>
            <div class="meme-description">"I was helping!"</div>
          </div>
        </div>
      `;
      
      document.getElementById('memeDetails').innerHTML = memeHtml;
      document.getElementById('memeContent').classList.remove('hidden');
    }

    // Function to show Team Records
    function showTeamRecords() {
      // Use cached records if available, otherwise calculate fresh
      const records = cachedRecords || calculateTeamRecords();
      
      if (!cachedRecords) {
        console.log('‚ö†Ô∏è No cached records found, calculating fresh records');
        cachedRecords = records; // Cache for next time
      } else {
        console.log('‚úÖ Using pre-calculated cached records');
      }
      
      const recordsHtml = `
        <div class="records-grid">
          <div class="record-card">
            <div class="record-trophy">üèÜ</div>
            <div class="record-title">Highest Single Match Damage</div>
            <div class="record-holder">${records.topDamage.player}</div>
            <div class="record-value">${records.topDamage.value.toLocaleString()}</div>
            <div class="record-date">üìÖ ${records.topDamage.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üíÄ</div>
            <div class="record-title">Most Kills in One Match</div>
            <div class="record-holder">${records.topKills.player}</div>
            <div class="record-value">${records.topKills.value}</div>
            <div class="record-date">üìÖ ${records.topKills.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üéØ</div>
            <div class="record-title">Best Team Damage Combined</div>
            <div class="record-holder">Team Record</div>
            <div class="record-value">${records.teamDamage.value.toLocaleString()}</div>
            <div class="record-date">üìÖ ${records.teamDamage.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üíä</div>
            <div class="record-title">Most Revives in One Match</div>
            <div class="record-holder">${records.topRevives.player}</div>
            <div class="record-value">${records.topRevives.value}</div>
            <div class="record-date">üìÖ ${records.topRevives.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üè•</div>
            <div class="record-title">Healing Champion</div>
            <div class="record-holder">${records.topHeals.player}</div>
            <div class="record-value">${records.topHeals.value}</div>
            <div class="record-date">üìÖ ${records.topHeals.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üöÄ</div>
            <div class="record-title">Boost Master</div>
            <div class="record-holder">${records.topBoosts.player}</div>
            <div class="record-value">${records.topBoosts.value}</div>
            <div class="record-date">üìÖ ${records.topBoosts.date}</div>
          </div>
        </div>
      `;
      
      document.getElementById('recordsDetails').innerHTML = recordsHtml;
      document.getElementById('recordsContent').classList.remove('hidden');
    }

    // Function to show changelog
    function showChangelog() {
      const changelogHtml = `
        <div style="max-width: 800px; margin: 0 auto;">
          <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #333; margin-top: 0;">üìã PUBG Tracker Development History</h3>
            <p style="color: #666; margin-bottom: 0;">Track the evolution of your favorite PUBG performance dashboard!</p>
          </div>
          
          <div style="border-left: 4px solid #e67e22; padding-left: 20px; margin-bottom: 30px;">
            <div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="color: #e67e22; margin: 0;">Version 1.1 üîî</h4>
                <span style="background: #e67e22; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">19.10.2025</span>
              </div>
              <ul style="margin: 10px 0; color: #333;">
                <li><strong>Discord Integration:</strong> Real-time match notifications to Discord channel</li>
                <li><strong>Smart Detection:</strong> Automatic new match detection every 10 minutes</li>
                <li><strong>Rich Notifications:</strong> Performance stats, team composition, and match details</li>
                <li><strong>Duplicate Prevention:</strong> State tracking prevents duplicate notifications</li>
                <li><strong>Enhanced Records:</strong> Automatic record recalculation with every data sync</li>
                <li><strong>UI Improvements:</strong> Separate buttons for special sections, date/time in records</li>
                <li><strong>Real Sync Timestamps:</strong> Display actual GitHub Actions execution time</li>
              </ul>
              <div style="background: #fff3cd; border-radius: 4px; padding: 10px; margin-top: 15px;">
                <small style="color: #856404;">
                  <strong>New Feature Highlight:</strong> Get instant Discord notifications when you finish a PUBG match! 
                  Rich embeds show kills, damage, placement, teammates, and match timing in Prague timezone.
                </small>
              </div>
            </div>
          </div>
          
          <div style="border-left: 4px solid #28a745; padding-left: 20px; margin-bottom: 30px;">
            <div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="color: #28a745; margin: 0;">Version 1.0 üéâ</h4>
                <span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">18.10.2025</span>
              </div>
              <ul style="margin: 10px 0; color: #333;">
                <li><strong>Initial Release:</strong> Complete PUBG performance tracking dashboard</li>
                <li><strong>Core Features:</strong> Daily summaries, match details, weapon analytics</li>
                <li><strong>Team System:</strong> Composition filtering and player statistics</li>
                <li><strong>Player BIOs:</strong> Humorous player profiles with favorite weapons</li>
                <li><strong>Special Sections:</strong> Meme dashboard and team records</li>
                <li><strong>Automation:</strong> Scheduled data collection via GitHub Actions</li>
                <li><strong>Deployment:</strong> Automated CI/CD pipeline to webzdarma.cz hosting</li>
                <li><strong>Cache Management:</strong> Smart data refresh and sync tracking</li>
              </ul>
              <div style="background: #f8f9fa; border-radius: 4px; padding: 10px; margin-top: 15px;">
                <small style="color: #666;">
                  <strong>Technical Stack:</strong> HTML5, JavaScript ES6, Chart.js, Node.js, PUBG API, GitHub Actions
                </small>
              </div>
            </div>
          </div>
          
          <div style="text-align: center; color: #666; font-style: italic;">
            <small>üöÄ Latest: Discord notifications now live! More exciting features in development...</small>
          </div>
        </div>
      `;
      
      document.getElementById('changelogDetails').innerHTML = changelogHtml;
      document.getElementById('changelogContent').classList.remove('hidden');
    }

    // Function to calculate meme statistics
    function calculateMemeStats() {
      if (!matchData || matchData.length === 0) {
        return {
          mostRevives: 'Unknown',
          topDamager: 'Unknown',
          killStealer: 'Unknown'
        };
      }

      const playerStats = {};
      matchData.forEach(match => {
        match.team.forEach(player => {
          if (!playerStats[player.name]) {
            playerStats[player.name] = { 
              revives: 0, damage: 0, kills: 0, matches: 0 
            };
          }
          playerStats[player.name].revives += player.revives || 0;
          playerStats[player.name].damage += player.damage || 0;
          playerStats[player.name].kills += player.kills || 0;
          playerStats[player.name].matches++;
        });
      });

      const mostRevives = Object.entries(playerStats)
        .sort((a, b) => b[1].revives - a[1].revives)[0]?.[0] || 'Unknown';
      
      const topDamager = Object.entries(playerStats)
        .sort((a, b) => b[1].damage - a[1].damage)[0]?.[0] || 'Unknown';
      
      const killStealer = Object.entries(playerStats)
        .sort((a, b) => {
          const aRatio = a[1].kills / Math.max(a[1].damage, 1);
          const bRatio = b[1].kills / Math.max(b[1].damage, 1);
          return bRatio - aRatio;
        })[0]?.[0] || 'Unknown';

      return { mostRevives, topDamager, killStealer };
    }

    // Function to calculate team records
    function calculateTeamRecords() {
      if (!matchData || matchData.length === 0) {
        return {
          topDamage: { player: 'Unknown', value: 0, date: 'N/A' },
          topKills: { player: 'Unknown', value: 0, date: 'N/A' },
          teamDamage: { value: 0, date: 'N/A' },
          topRevives: { player: 'Unknown', value: 0, date: 'N/A' },
          topHeals: { player: 'Unknown', value: 0, date: 'N/A' },
          topBoosts: { player: 'Unknown', value: 0, date: 'N/A' }
        };
      }

      let topDamage = { player: '', value: 0, date: '' };
      let topKills = { player: '', value: 0, date: '' };
      let teamDamage = { value: 0, date: '' };
      let topRevives = { player: '', value: 0, date: '' };
      let topHeals = { player: '', value: 0, date: '' };
      let topBoosts = { player: '', value: 0, date: '' };

      matchData.forEach(match => {
        let matchTeamDamage = 0;
        const matchDate = new Date(match.date).toLocaleDateString('en-GB', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        match.team.forEach(player => {
          // Track individual records with dates
          if (player.damage > topDamage.value) {
            topDamage = { player: player.name, value: player.damage, date: matchDate };
          }
          if (player.kills > topKills.value) {
            topKills = { player: player.name, value: player.kills, date: matchDate };
          }
          if (player.revives > topRevives.value) {
            topRevives = { player: player.name, value: player.revives, date: matchDate };
          }
          if (player.heals > topHeals.value) {
            topHeals = { player: player.name, value: player.heals, date: matchDate };
          }
          if (player.boosts > topBoosts.value) {
            topBoosts = { player: player.name, value: player.boosts, date: matchDate };
          }
          
          matchTeamDamage += player.damage || 0;
        });
        
        if (matchTeamDamage > teamDamage.value) {
          teamDamage = { value: matchTeamDamage, date: matchDate };
        }
      });

      return { topDamage, topKills, teamDamage, topRevives, topHeals, topBoosts };
    }
  </script>
</body>
</html>