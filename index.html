<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PUBG Tracker Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 20px;
      margin: 0;
      box-sizing: border-box;
      background-color: #f5f5f5;
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .controls {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
    }
    
    .dropdown-container {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    select {
      padding: 10px 15px;
      border: 2px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
      background: white;
      cursor: pointer;
    }
    
    select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .content-section {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 30px;
      overflow: hidden;
    }
    
    .section-header {
      background: #667eea;
      color: white;
      padding: 15px 20px;
      font-weight: bold;
      font-size: 18px;
    }
    
    .section-content {
      padding: 20px;
    }
    
    .charts-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .chart-container {
      background: white;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 15px;
      position: relative;
      height: 300px;
      min-height: 300px;
      width: 100%;
    }
    
    .chart-container canvas {
      width: 100% !important;
      height: 280px !important;
      max-height: 280px;
    }
    
    .stats-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }
    
    .stat-title {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }
    
    .hidden {
      display: none !important;
    }
    
    canvas {
      width: 100% !important;
      height: 100% !important;
    }
    
    .weapons-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .weapon-chart {
      height: 250px;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 10px;
    }

    .player-bio {
      text-align: center;
    }

    .player-bio h2 {
      color: #667eea;
      margin-bottom: 20px;
      font-size: 28px;
    }

    .bio-content {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      border-left: 4px solid #667eea;
    }

    .bio-content p {
      font-size: 18px;
      line-height: 1.6;
      color: #555;
      margin: 0;
      font-style: italic;
    }

    .bio-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .meme-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .meme-card {
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .meme-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .meme-value {
      font-size: 24px;
      margin: 10px 0;
    }

    .meme-description {
      font-size: 14px;
      opacity: 0.9;
      font-style: italic;
    }

    .records-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .record-card {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .record-trophy {
      font-size: 30px;
      margin-bottom: 10px;
    }

    .record-title {
      font-size: 16px;
      margin-bottom: 10px;
      font-weight: bold;
    }

    .record-holder {
      font-size: 20px;
      margin: 10px 0;
      color: #ffd700;
    }

    .record-value {
      font-size: 24px;
      font-weight: bold;
      margin: 5px 0;
    }

    .record-date {
      font-size: 12px;
      color: #e0e0e0;
      margin-top: 8px;
      font-style: italic;
    }

    .special-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 5px;
    }

    .special-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .special-btn:hover {
      background: linear-gradient(135deg, #764ba2, #667eea);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .special-btn:active, .special-btn.active {
      background: linear-gradient(135deg, #5a67d8, #553c9a);
      transform: translateY(0);
    }

    /* Player Selection Styles */
    .player-selection {
      margin-bottom: 20px;
    }

    .player-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }

    .player-btn {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border: 2px solid #dee2e6;
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      font-family: inherit;
    }

    .player-btn:hover {
      background: linear-gradient(135deg, #e9ecef, #f8f9fa);
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
    }

    .player-btn.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-color: #667eea;
      color: white;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .player-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .player-name {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 4px;
    }

    .player-role {
      font-size: 12px;
      opacity: 0.8;
    }

    .player-bio {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 12px;
      padding: 20px;
      width: 100%;
      margin-top: 20px;
    }

    .player-bio h3 {
      color: #667eea;
      margin: 0 0 15px 0;
      font-size: 20px;
    }

    .bio-content {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .bio-content p {
      margin: 5px 0;
      line-height: 1.4;
      flex: 1;
      min-width: 250px;
    }
  </style>
</head>
<body>
  <div class="header" id="mainHeader" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <div style="flex: 1;">
        <h1>üéÆ PUBG Performance Dashboard</h1>
        <p>Track your team's performance with detailed statistics and weapon analytics</p>
        <p><small id="lastUpdated">Loading sync information...</small></p>
      </div>
      <div>
        <button id="returnToDashboard" class="special-btn" style="display: none; padding: 12px 24px; font-size: 14px; background: #6c757d; border-color: #6c757d;">
          üè† Return to Dashboard
        </button>
      </div>
    </div>
  </div>

  <!-- Welcome Screen -->
  <div id="welcomeScreen" class="content-section" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px; padding: 30px; margin: 20px 0; text-align: center;">
    <h2 style="margin: 0 0 20px 0; font-size: 28px;">üéÆ Welcome to PUBG Performance Tracker!</h2>
    
    <div style="background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px; margin: 20px 0; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto;">
      <h3 style="margin: 0 0 15px 0; color: #fff;">üìñ Quick Start Guide</h3>
      
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px;">
        <div>
          <strong>üë• Select a Player</strong>
          <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">Choose from 6 squad members below to view their individual stats and match history</p>
        </div>
        <div>
          <strong>üìä View Statistics</strong>
          <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">Use the day/match dropdowns to explore detailed performance data and charts</p>
        </div>
        <div>
          <strong>ü§° Special Sections</strong>
          <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">Check out Meme Dashboard, Team Records, and Changelog using the buttons in the header</p>
        </div>
      </div>
      
      <div style="background: rgba(255, 255, 255, 0.15); border-radius: 6px; padding: 12px; margin-top: 15px;">
        <strong>üí° Pro Tip:</strong> Data is automatically collected 3 times daily (8PM, 9PM, 10PM Prague time) via GitHub Actions
      </div>
    </div>
    
    <div style="margin-top: 10px; font-size: 18px; font-weight: bold;">
      ‚¨áÔ∏è Select a Player Below to Get Started ‚¨áÔ∏è
    </div>
  </div>

  <!-- Player Selection -->
  <div class="content-section">
    <div class="section-header">üë• Select Player</div>
    <div class="section-content">
      <div class="player-selection">
        <div class="player-buttons">
          <button class="player-btn active" data-player="Kilma9">
            <div class="player-icon">üéÆ</div>
            <div class="player-name">Kilma9</div>
            <div class="player-role">Main Player</div>
          </button>
          <button class="player-btn" data-player="Mar-0">
            <div class="player-icon">‚öîÔ∏è</div>
            <div class="player-name">Mar-0</div>
            <div class="player-role">Squad Member</div>
          </button>
          <button class="player-btn" data-player="Hyottokko">
            <div class="player-icon">üî•</div>
            <div class="player-name">Hyottokko</div>
            <div class="player-role">Squad Member</div>
          </button>
          <button class="player-btn" data-player="Baron_Frajeris">
            <div class="player-icon">üëë</div>
            <div class="player-name">Baron_Frajeris</div>
            <div class="player-role">Squad Member</div>
          </button>
          <button class="player-btn" data-player="codufus">
            <div class="player-icon">üéØ</div>
            <div class="player-name">codufus</div>
            <div class="player-role">Squad Member</div>
          </button>
          <button class="player-btn" data-player="Veru_13">
            <div class="player-icon">üõ°Ô∏è</div>
            <div class="player-name">Veru_13</div>
            <div class="player-role">Squad Member</div>
          </button>
        </div>
      </div>
      
      <!-- Player Bio Section - Now below the buttons -->
      <div id="playerBio" class="player-bio hidden">
        <h3 id="bioPlayerName">Kilma9</h3>
        <div id="bioContent" class="bio-content">
          <p><strong>üéÆ Main Player & Squad Leader</strong></p>
          <p>üìä Primary statistics tracking and dashboard owner</p>
          <p>üèÜ Active PUBG player focused on squad gameplay</p>
          <p>‚öîÔ∏è Prefers strategic positioning and team coordination</p>
          <p>üìà Tracks detailed performance metrics for team improvement</p>
        </div>
      </div>
    </div>
  </div>
  
  <div id="knownBugs" class="content-section hidden" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0;">
    <div class="section-header" style="color: #856404; font-size: 14px; margin-bottom: 5px;">‚ö†Ô∏è Known Issues</div>
    <div style="font-size: 12px; color: #856404;">
      <ul style="margin: 5px 0; padding-left: 20px;">
        <li><strong>Weapon Damage:</strong> Includes damage to wildlife (bears) and self/team damage from grenades/vehicles</li>
        <li><strong>Team Damage:</strong> Friendly fire and environmental damage is counted in statistics</li>
        <li><strong>Data Sync:</strong> Cache issues may show outdated match data - use hard refresh (Ctrl+Shift+R)</li>
      </ul>
      <small style="font-style: italic;">These will be addressed in future updates</small>
    </div>
  </div>
  
  <div class="controls">
    <div class="dropdown-container">
      <label><strong>Select Day:</strong></label>
      <select id="daySelect">
        <option value="">Choose a day...</option>
      </select>
      
      <label><strong>Team Filter:</strong></label>
      <select id="teamCompositionSelect">
        <option value="all">All Compositions</option>
        <option value="">Loading...</option>
      </select>
      
      <label><strong>Team Size:</strong></label>
      <select id="teamSizeSelect">
        <option value="all">All Sizes</option>
        <option value="solo">üë§ Solo</option>
        <option value="duo">üë• Duo</option>
        <option value="squad" selected>üë™ Squad</option>
      </select>
      
      <label><strong>Select Match:</strong></label>
      <select id="matchSelect" disabled>
        <option value="">Choose a match...</option>
      </select>
      

      
      <label><strong>Special Sections:</strong></label>
      <div class="special-buttons">
        <button id="memesBtn" class="special-btn">ü§° Meme Dashboard</button>
        <button id="recordsBtn" class="special-btn">üèÜ Team Records</button>
        <button id="changelogBtn" class="special-btn">üìã Changelog</button>
      </div>
    </div>
  </div>
  
  <div id="dayContent" class="content-section hidden">
    <div class="section-header">Daily Summary</div>
    <div class="section-content">
      <div id="daySummary"></div>
      <div id="dayCharts"></div>
    </div>
  </div>
  
  <div id="matchContent" class="content-section hidden">
    <div class="section-header">Match Details</div>
    <div class="section-content">
      <div id="matchSummary"></div>
      <div id="matchCharts"></div>
    </div>
  </div>

  <div id="bioContent" class="content-section hidden">
    <div class="section-header">Player Biography</div>
    <div class="section-content">
      <div id="bioDetails"></div>
    </div>
  </div>

  <div id="memeContent" class="content-section hidden">
    <div class="section-header">ü§° Meme Dashboard - Hall of Fame</div>
    <div class="section-content">
      <div id="memeDetails"></div>
    </div>
  </div>

  <div id="recordsContent" class="content-section hidden">
    <div class="section-header">üèÜ Team Records & Achievements</div>
    <div class="section-content">
      <div id="recordsDetails"></div>
    </div>
  </div>

  <div id="changelogContent" class="content-section hidden">
    <div class="section-header">üìã Changelog</div>
    <div class="section-content">
      <div id="changelogDetails"></div>
    </div>
  </div>

  <script>
    let matchData = [];
    let fullMatchData = []; // Keep full dataset for memes, records, changelog
    let currentCharts = [];
    let cachedRecords = null; // Cache for pre-calculated records
    let currentPlayer = 'Kilma9'; // Default player

    // Player data and BIO information
    const playerData = {
      'Kilma9': {
        icon: 'üéÆ',
        role: 'Web Owner',
        bio: `
          <p><strong>ÔøΩ Web Owner</strong></p>
          <p>üìä Primary statistics tracking and dashboard owner</p>
          <p>üèÜ Active PUBG player focused on squad gameplay</p>
          <p>‚öîÔ∏è Prefers strategic positioning and team coordination</p>
          <p>üìà Tracks detailed performance metrics for team improvement</p>
        `,
        dataFile: 'data.json'
      },
      'Mar-0': {
        icon: '‚öîÔ∏è',
        role: 'Squad Member',
        bio: `
          <p><strong>‚öîÔ∏è Aggressive Fragger</strong></p>
          <p>üî• Known for high-kill games and aggressive pushes</p>
          <p>üéØ Excellent with assault rifles and SMGs</p>
          <p>üèÉ Fast-paced playstyle with strong mechanical skills</p>
          <p>üí™ Team's primary entry fragger and damage dealer</p>
        `,
        dataFile: 'data_Mar-0.json'
      },
      'Hyottokko': {
        icon: 'üî•',
        role: 'Squad Member',
        bio: `
          <p><strong>üî• Versatile Player</strong></p>
          <p>üéØ Balanced approach between aggression and strategy</p>
          <p>üõ°Ô∏è Reliable team player with consistent performance</p>
          <p>üìà Steady improvement and adaptation to team needs</p>
          <p>ü§ù Strong communication and tactical awareness</p>
        `,
        dataFile: 'data_Hyottokko.json'
      },
      'Baron_Frajeris': {
        icon: 'üëë',
        role: 'Squad Member',
        bio: `
          <p><strong>üëë Strategic Mind</strong></p>
          <p>üß† Tactical player with excellent game sense</p>
          <p>üéØ Sniper specialist with long-range expertise</p>
          <p>üó∫Ô∏è Map knowledge expert and rotation caller</p>
          <p>üéñÔ∏è Clutch player in high-pressure situations</p>
        `,
        dataFile: 'data_Baron_Frajeris.json'
      },
      'codufus': {
        icon: 'üéØ',
        role: 'Squad Member',
        bio: `
          <p><strong>üéØ Precision Player</strong></p>
          <p>üèπ Accurate shooter with excellent aim</p>
          <p>üîç Detail-oriented with strong positioning</p>
          <p>üõ†Ô∏è Equipment and utility specialist</p>
          <p>‚öñÔ∏è Balanced playstyle adapting to team needs</p>
        `,
        dataFile: 'data_codufus.json'
      },
      'Veru_13': {
        icon: 'üõ°Ô∏è',
        role: 'Squad Member',
        bio: `
          <p><strong>üõ°Ô∏è Support Specialist</strong></p>
          <p>üè• Team medic and support player</p>
          <p>üöó Vehicle expert and rotation coordinator</p>
          <p>üëÅÔ∏è Excellent scout with strong awareness</p>
          <p>ü§≤ Selfless team player focused on squad success</p>
        `,
        dataFile: 'data_Veru_13.json'
      }
    };

    // Utility function to clean weapon names
    function cleanWeaponName(weapon) {
      return weapon.replace(/^(Weap |Proj )/i, '').replace(/_/g, ' ').trim();
    }

    // Utility function to destroy existing charts
    function destroyCharts() {
      currentCharts.forEach(chart => {
        if (chart && typeof chart.destroy === 'function') {
          chart.destroy();
        }
      });
      currentCharts = [];
    }

    // Initialize with default player data
    async function initializeDashboard() {
      // Don't load any player by default - show welcome screen instead
      console.log('Dashboard initialized - showing welcome screen');
      
      // Remove active state from all player buttons
      document.querySelectorAll('.player-btn').forEach(btn => {
        btn.classList.remove('active');
      });
    }

    // Initialize dashboard on page load
    initializeDashboard();

    // Update sync information with Prague time
    async function updateSyncInfo(data) {
      try {
        // Try to fetch the actual sync timestamp first
        let actualSyncTime = null;
        try {
          const syncResponse = await fetch(`/last-sync.json?v=${new Date().getTime()}`);
          if (syncResponse.ok) {
            const syncData = await syncResponse.json();
            actualSyncTime = syncData.pragueTime;
          }
        } catch (syncError) {
          console.log('No sync timestamp file found, using fallback');
        }

        // Find the most recent match
        let latestMatch = null;
        let latestTime = 0;
        
        data.forEach(match => {
          const matchTime = new Date(match.date).getTime();
          if (matchTime > latestTime) {
            latestTime = matchTime;
            latestMatch = match;
          }
        });

        let syncInfo;
        if (actualSyncTime) {
          syncInfo = `Data collected: ${actualSyncTime} (Prague) - ${data.length} matches`;
        } else {
          // Fallback: show page load time
          const pageLoadTime = new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Prague',
            day: 'numeric',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit'
          }).format(new Date());
          syncInfo = `Page loaded: ${pageLoadTime} (Prague) - ${data.length} matches`;
        }
        
        if (latestMatch) {
          const lastMatchPragueTime = new Intl.DateTimeFormat('en-GB', {
            timeZone: 'Europe/Prague',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
          }).format(new Date(latestMatch.date));
          
          syncInfo += ` | Latest match: ${lastMatchPragueTime} (Prague)`;
        }

        document.getElementById('lastUpdated').textContent = syncInfo;
      } catch (error) {
        console.error('Error updating sync info:', error);
        document.getElementById('lastUpdated').textContent = `Fresh data with ${data.length} matches!`;
      }
    }

    function populateDayDropdown() {
      const daySelect = document.getElementById('daySelect');
      const days = [...new Set(matchData.map(match => match.date.split('T')[0]))].sort().reverse();
      
      days.forEach(day => {
        const option = document.createElement('option');
        option.value = day;
        option.textContent = day;
        daySelect.appendChild(option);
      });
    }

    function populateMatchDropdown(selectedDay) {
      const matchSelect = document.getElementById('matchSelect');
      matchSelect.innerHTML = '<option value="">Choose a match...</option>';
      
      const teamComposition = document.getElementById('teamCompositionSelect').value;
      const teamSize = document.getElementById('teamSizeSelect').value;
      const dayMatches = getFilteredMatches(selectedDay, teamComposition, teamSize);
      
      dayMatches.forEach((match, index) => {
        const option = document.createElement('option');
        option.value = index.toString();
        const time = new Date(match.date).toLocaleTimeString();
        const teamNames = match.team.map(p => p.name).join(', ');
        
        option.textContent = `Match ${index + 1} (${time}) - ${teamNames}`;
        matchSelect.appendChild(option);
      });
      
      matchSelect.disabled = dayMatches.length === 0;
    }

    // Get unique team compositions
    function getTeamCompositions() {
      const compositions = new Set();
      matchData.forEach(match => {
        const teamNames = match.team.map(player => player.name).sort().join(', ');
        compositions.add(teamNames);
      });
      return Array.from(compositions).sort();
    }

    // Populate team composition dropdown
    function populateTeamCompositions() {
      const teamSelect = document.getElementById('teamCompositionSelect');
      teamSelect.innerHTML = '<option value="all">All Compositions</option>';
      
      const compositions = getTeamCompositions();
      compositions.forEach(composition => {
        const option = document.createElement('option');
        option.value = composition;
        option.textContent = `${composition} (${getCompositionMatchCount(composition)} matches)`;
        teamSelect.appendChild(option);
      });
    }

    // Get match count for a specific team composition
    function getCompositionMatchCount(composition) {
      return matchData.filter(match => {
        const teamNames = match.team.map(player => player.name).sort().join(', ');
        return teamNames === composition;
      }).length;
    }

    // Filter matches by team composition and team size
    function getFilteredMatches(day, teamComposition = 'all', teamSize = 'squad') {
      let filtered = matchData.filter(match => match.date.split('T')[0] === day);
      
      // Filter by team composition
      if (teamComposition !== 'all') {
        filtered = filtered.filter(match => {
          const teamNames = match.team.map(player => player.name).sort().join(', ');
          return teamNames === teamComposition;
        });
      }
      
      // Filter by team size (solo/duo/squad) - default to squad
      if (teamSize !== 'all') {
        filtered = filtered.filter(match => {
          if (!match.teamSize) {
            // For matches without teamSize data, infer from team length
            const teamLength = match.team.length;
            const inferredSize = teamLength === 1 ? 'solo' : teamLength === 2 ? 'duo' : 'squad';
            return inferredSize === teamSize;
          }
          return match.teamSize === teamSize;
        });
      }
      
      return filtered;
    }

    function showDaySummary(day) {
      destroyCharts();
      const teamComposition = document.getElementById('teamCompositionSelect').value;
      const teamSize = document.getElementById('teamSizeSelect').value;
      const dayMatches = getFilteredMatches(day, teamComposition, teamSize);
      
      console.log('Processing day:', day, 'with', dayMatches.length, 'matches');
      console.log('Filters:', { teamComposition, teamSize });
      
      if (dayMatches.length === 0) {
        document.getElementById('daySummary').innerHTML = `
          <div class="stat-card">
            <div class="stat-title">No Matches Found</div>
            <div class="stat-value">No matches for selected team composition on ${day}</div>
          </div>
        `;
        document.getElementById('dayContent').classList.remove('hidden');
        return;
      }
      
      // Calculate daily aggregated stats
      const playerStats = {};
      dayMatches.forEach(match => {
        match.team.forEach(player => {
          if (!playerStats[player.name]) {
            playerStats[player.name] = {
              kills: 0, damage: 0, headshots: 0, assists: 0, 
              boosts: 0, heals: 0, revives: 0, matches: 0,
              weapons: {}, weaponDamage: {}
            };
          }
          const stats = playerStats[player.name];
          stats.kills += player.kills || 0;
          stats.damage += player.damage || 0;
          stats.headshots += player.headshots || 0;
          stats.assists += player.assists || 0;
          stats.boosts += player.boosts || 0;
          stats.heals += player.heals || 0;
          stats.revives += player.revives || 0;
          stats.matches++;
          
          // Aggregate weapon damage
          Object.entries(player.weaponDamage || {}).forEach(([weapon, damage]) => {
            if (weapon.includes('Player') || weapon.includes('Effect')) return;
            const cleanName = cleanWeaponName(weapon);
            if (!stats.weaponDamage[cleanName]) stats.weaponDamage[cleanName] = 0;
            stats.weaponDamage[cleanName] += damage;
          });
        });
      });

      console.log('Player stats calculated:', Object.keys(playerStats).length, 'players');

      // Display summary stats
      const summaryHtml = `
        <div class="stats-summary">
          <div class="stat-card">
            <div class="stat-title">Total Matches</div>
            <div class="stat-value">${dayMatches.length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Players</div>
            <div class="stat-value">${Object.keys(playerStats).length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Total Kills</div>
            <div class="stat-value">${Object.values(playerStats).reduce((sum, p) => sum + p.kills, 0)}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Total Damage</div>
            <div class="stat-value">${Math.round(Object.values(playerStats).reduce((sum, p) => sum + p.damage, 0)).toLocaleString()}</div>
          </div>
        </div>
      `;
      
      document.getElementById('daySummary').innerHTML = summaryHtml;

      // Create charts
      const chartsHtml = `
        <div class="charts-grid">
          <div class="chart-container"><canvas id="dayKillsChart"></canvas></div>
          <div class="chart-container"><canvas id="dayDamageChart"></canvas></div>
          <div class="chart-container"><canvas id="dayHeadshotsChart"></canvas></div>
          <div class="chart-container"><canvas id="dayAssistsChart"></canvas></div>
        </div>
        <div id="weaponCharts" class="weapons-grid"></div>
      `;
      
      document.getElementById('dayCharts').innerHTML = chartsHtml;

      // Show the day content first
      document.getElementById('dayContent').classList.remove('hidden');

      // Use setTimeout to ensure DOM is ready before creating charts
      setTimeout(() => {
        const players = Object.keys(playerStats);
        console.log('Creating charts for players:', players);
        
        if (players.length === 0) {
          console.error('No players found for charts');
          return;
        }

        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { 
            legend: { display: false },
            title: { display: true }
          },
          scales: { 
            y: { beginAtZero: true }
          },
          animation: false // Disable animation for faster rendering
        };

        // Check if canvas elements exist before creating charts
        const killsCanvas = document.getElementById('dayKillsChart');
        const damageCanvas = document.getElementById('dayDamageChart');
        const headshotsCanvas = document.getElementById('dayHeadshotsChart');
        const assistsCanvas = document.getElementById('dayAssistsChart');

        console.log('Canvas elements found:', {
          kills: !!killsCanvas,
          damage: !!damageCanvas,
          headshots: !!headshotsCanvas,
          assists: !!assistsCanvas
        });

        if (!killsCanvas || !damageCanvas || !headshotsCanvas || !assistsCanvas) {
          console.error('Canvas elements not found');
          return;
        }

        // Performance charts
        try {
          console.log('Creating kills chart...');
          const killsChart = new Chart(killsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Kills',
                data: players.map(p => playerStats[p].kills),
                backgroundColor: '#ff6b6b',
                borderColor: '#ff5252',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Kills' } 
              } 
            }
          });
          currentCharts.push(killsChart);
          console.log('Kills chart created successfully');

          console.log('Creating damage chart...');
          const damageChart = new Chart(damageCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Damage',
                data: players.map(p => Math.round(playerStats[p].damage)),
                backgroundColor: '#4ecdc4',
                borderColor: '#26d0ce',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Damage' } 
              } 
            }
          });
          currentCharts.push(damageChart);
          console.log('Damage chart created successfully');

          console.log('Creating headshots chart...');
          const headshotsChart = new Chart(headshotsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Headshots',
                data: players.map(p => playerStats[p].headshots),
                backgroundColor: '#45b7d1',
                borderColor: '#3742fa',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Headshots' } 
              } 
            }
          });
          currentCharts.push(headshotsChart);
          console.log('Headshots chart created successfully');

          console.log('Creating assists chart...');
          const assistsChart = new Chart(assistsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                label: 'Assists',
                data: players.map(p => playerStats[p].assists),
                backgroundColor: '#f7b731',
                borderColor: '#fa8231',
                borderWidth: 1
              }]
            },
            options: { 
              ...chartOptions, 
              plugins: { 
                ...chartOptions.plugins, 
                title: { display: true, text: 'Total Assists' } 
              } 
            }
          });
          currentCharts.push(assistsChart);
          console.log('Assists chart created successfully');

          console.log('All main charts created successfully. Total charts:', currentCharts.length);
        } catch (error) {
          console.error('Error creating main charts:', error);
        }

        // Weapon charts for each player
        const weaponChartsContainer = document.getElementById('weaponCharts');
        if (weaponChartsContainer) {
          weaponChartsContainer.innerHTML = '';
          
          players.forEach(player => {
            const weapons = Object.entries(playerStats[player].weaponDamage)
              .filter(([weapon, damage]) => damage > 0)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 10); // Top 10 weapons
            
            if (weapons.length > 0) {
              const chartDiv = document.createElement('div');
              chartDiv.className = 'weapon-chart';
              const cleanPlayerId = player.replace(/[^a-zA-Z0-9]/g, '_');
              chartDiv.innerHTML = `<canvas id="weapon-${cleanPlayerId}"></canvas>`;
              weaponChartsContainer.appendChild(chartDiv);
              
              console.log(`Creating weapon chart for ${player} with ${weapons.length} weapons`);
              
              // Use another setTimeout for weapon charts
              setTimeout(() => {
                const weaponCanvas = document.getElementById(`weapon-${cleanPlayerId}`);
                if (weaponCanvas) {
                  try {
                    const weaponChart = new Chart(weaponCanvas, {
                      type: 'doughnut',
                      data: {
                        labels: weapons.map(([weapon]) => weapon),
                        datasets: [{
                          data: weapons.map(([_, damage]) => Math.round(damage)),
                          backgroundColor: [
                            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                            '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                          ]
                        }]
                      },
                      options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                          title: { display: true, text: `${player} - Weapon Damage` },
                          legend: { position: 'bottom', labels: { boxWidth: 12, fontSize: 10 } }
                        }
                      }
                    });
                    currentCharts.push(weaponChart);
                    console.log(`Weapon chart created for ${player}`);
                  } catch (error) {
                    console.error(`Error creating weapon chart for ${player}:`, error);
                  }
                } else {
                  console.error(`Weapon canvas not found for ${player}`);
                }
              }, 200);
            }
          });
        }

        // Final check and debug info
        setTimeout(() => {
          console.log('Final chart count:', currentCharts.length);
          console.log('Chart containers visible:', {
            dayContent: !document.getElementById('dayContent').classList.contains('hidden'),
            chartsGrid: !!document.querySelector('.charts-grid'),
            chartContainers: document.querySelectorAll('.chart-container').length
          });
        }, 500);
      }, 250); // Increased timeout to give more time for DOM rendering
    }

    function showMatchDetails(dayMatches, matchIndex) {
      destroyCharts(); // Only destroy charts, keep day summary visible
      const match = dayMatches[matchIndex];
      
      console.log('Showing match details for match', matchIndex);
      console.log('Match data:', match);
      
      if (!match) {
        console.error('No match found at index', matchIndex);
        document.getElementById('matchSummary').innerHTML = '<div class="stat-card"><div class="stat-title">Error</div><div class="stat-value">Match not found</div></div>';
        return;
      }
      
      // Match summary
      const summaryHtml = `
        <div class="stats-summary">
          <div class="stat-card">
            <div class="stat-title">Match Time</div>
            <div class="stat-value">${new Date(match.date).toLocaleString()}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Size</div>
            <div class="stat-value">${match.team.length}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Kills</div>
            <div class="stat-value">${match.team.reduce((sum, p) => sum + (p.kills || 0), 0)}</div>
          </div>
          <div class="stat-card">
            <div class="stat-title">Team Damage</div>
            <div class="stat-value">${Math.round(match.team.reduce((sum, p) => sum + (p.damage || 0), 0)).toLocaleString()}</div>
          </div>
        </div>
      `;
      
      document.getElementById('matchSummary').innerHTML = summaryHtml;

      // Match charts
      const chartsHtml = `
        <div class="charts-grid">
          <div class="chart-container"><canvas id="matchKillsChart"></canvas></div>
          <div class="chart-container"><canvas id="matchDamageChart"></canvas></div>
          <div class="chart-container"><canvas id="matchHeadshotsChart"></canvas></div>
          <div class="chart-container"><canvas id="matchHealsChart"></canvas></div>
        </div>
        <div id="matchWeaponCharts" class="weapons-grid"></div>
      `;
      
      document.getElementById('matchCharts').innerHTML = chartsHtml;

      // Show match content
      const matchContentEl = document.getElementById('matchContent');
      console.log('Match content element:', matchContentEl);
      console.log('Match content classes before:', matchContentEl.className);
      matchContentEl.classList.remove('hidden');
      console.log('Match content classes after:', matchContentEl.className);
      console.log('Match content display:', window.getComputedStyle(matchContentEl).display);

      // Create match charts with delay
      setTimeout(() => {
        const players = match.team.map(p => p.name);
        console.log('Creating match charts for players:', players);
        
        const chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { 
            legend: { display: false },
            title: { display: true }
          },
          scales: { 
            y: { beginAtZero: true }
          },
          animation: false
        };

        // Check canvas elements
        const killsCanvas = document.getElementById('matchKillsChart');
        const damageCanvas = document.getElementById('matchDamageChart');
        const headshotsCanvas = document.getElementById('matchHeadshotsChart');
        const healsCanvas = document.getElementById('matchHealsChart');

        console.log('Match canvas elements found:', {
          kills: !!killsCanvas,
          damage: !!damageCanvas,
          headshots: !!headshotsCanvas,
          heals: !!healsCanvas
        });

        if (!killsCanvas || !damageCanvas || !headshotsCanvas || !healsCanvas) {
          console.error('Match canvas elements not found');
          return;
        }

        try {
          // Performance charts
          const killsChart = new Chart(killsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => p.kills || 0),
                backgroundColor: '#ff6b6b',
                borderColor: '#ff5252',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Kills' } } }
          });
          currentCharts.push(killsChart);

          const damageChart = new Chart(damageCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => Math.round(p.damage || 0)),
                backgroundColor: '#4ecdc4',
                borderColor: '#26d0ce',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Damage' } } }
          });
          currentCharts.push(damageChart);

          const headshotsChart = new Chart(headshotsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => p.headshots || 0),
                backgroundColor: '#45b7d1',
                borderColor: '#3742fa',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Headshots' } } }
          });
          currentCharts.push(headshotsChart);

          const healsChart = new Chart(healsCanvas, {
            type: 'bar',
            data: {
              labels: players,
              datasets: [{
                data: match.team.map(p => (p.heals || 0) + (p.boosts || 0)),
                backgroundColor: '#26de81',
                borderColor: '#20bf6b',
                borderWidth: 1
              }]
            },
            options: { ...chartOptions, plugins: { ...chartOptions.plugins, title: { display: true, text: 'Heals + Boosts' } } }
          });
          currentCharts.push(healsChart);

          console.log('Match charts created successfully');
        } catch (error) {
          console.error('Error creating match charts:', error);
        }

        // Individual weapon charts for each player
        const weaponChartsContainer = document.getElementById('matchWeaponCharts');
        if (weaponChartsContainer) {
          weaponChartsContainer.innerHTML = '';
          
          match.team.forEach(player => {
            const weapons = Object.entries(player.weaponDamage || {})
              .filter(([weapon, damage]) => damage > 0 && !weapon.includes('Player') && !weapon.includes('Effect'))
              .map(([weapon, damage]) => [cleanWeaponName(weapon), damage])
              .sort((a, b) => b[1] - a[1]);
            
            if (weapons.length > 0) {
              const chartDiv = document.createElement('div');
              chartDiv.className = 'weapon-chart';
              const cleanPlayerId = player.name.replace(/[^a-zA-Z0-9]/g, '_');
              chartDiv.innerHTML = `<canvas id="match-weapon-${cleanPlayerId}"></canvas>`;
              weaponChartsContainer.appendChild(chartDiv);
              
              setTimeout(() => {
                const weaponCanvas = document.getElementById(`match-weapon-${cleanPlayerId}`);
                if (weaponCanvas) {
                  try {
                    const weaponChart = new Chart(weaponCanvas, {
                      type: 'doughnut',
                      data: {
                        labels: weapons.map(([weapon]) => weapon),
                        datasets: [{
                          data: weapons.map(([_, damage]) => Math.round(damage)),
                          backgroundColor: [
                            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                            '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43'
                          ]
                        }]
                      },
                      options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                          title: { display: true, text: `${player.name} - Weapon Damage` },
                          legend: { position: 'bottom', labels: { boxWidth: 12, fontSize: 10 } }
                        }
                      }
                    });
                    currentCharts.push(weaponChart);
                  } catch (error) {
                    console.error(`Error creating match weapon chart for ${player.name}:`, error);
                  }
                }
              }, 200);
            }
          });
        }
      }, 250);
    }

    // Event listeners
    document.getElementById('daySelect').addEventListener('change', function() {
      const selectedDay = this.value;
      
      console.log('Day selected:', selectedDay);
      
      if (selectedDay) {
        // Show main dashboard when day is selected
        toggleMainDashboard(false);
        
        // Reset bio and special dropdowns
        const bioSelect = document.getElementById('bioSelect');
        if (bioSelect) bioSelect.value = '';
        resetSpecialButtons();
        document.getElementById('bioContent').classList.add('hidden');
        document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
        
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        // Don't hide matchContent, just reset the match dropdown
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      } else {
        document.getElementById('matchSelect').disabled = true;
        document.getElementById('matchSelect').value = '';
        document.getElementById('dayContent').classList.add('hidden');
        document.getElementById('matchContent').classList.add('hidden');
        destroyCharts();
      }
    });

    // Player selection functionality
    function switchPlayer(playerName) {
      currentPlayer = playerName;
      
      // Hide welcome screen and show main header
      document.getElementById('welcomeScreen').classList.add('hidden');
      document.getElementById('mainHeader').style.display = 'block';
      document.getElementById('knownBugs').classList.remove('hidden');
      
      // Show return to dashboard button
      document.getElementById('returnToDashboard').style.display = 'block';
      
      // Update active button state
      document.querySelectorAll('.player-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.player === playerName) {
          btn.classList.add('active');
        }
      });
      
      // Update player bio
      updatePlayerBio(playerName);
      
      // Load player data
      loadPlayerData(playerName);
      
      // Reset dashboard state
      document.getElementById('daySelect').value = '';
      document.getElementById('matchSelect').value = '';
      document.getElementById('dayContent').classList.add('hidden');
      document.getElementById('matchContent').classList.add('hidden');
    }
    
    // Function to return to main dashboard (welcome screen)
    function returnToMainDashboard() {
      // Show welcome screen and hide header
      document.getElementById('welcomeScreen').classList.remove('hidden');
      document.getElementById('mainHeader').style.display = 'none';
      
      // Hide all content sections
      document.getElementById('dayContent').classList.add('hidden');
      document.getElementById('matchContent').classList.add('hidden');
      document.getElementById('bioContent').classList.add('hidden');
      document.getElementById('memeContent').classList.add('hidden');
      document.getElementById('recordsContent').classList.add('hidden');
      document.getElementById('changelogContent').classList.add('hidden');
      document.getElementById('playerBio').classList.add('hidden');
      document.getElementById('knownBugs').classList.add('hidden');
      
      // Hide return button
      document.getElementById('returnToDashboard').style.display = 'none';
      
      // Reset header to default
      document.querySelector('.header h1').textContent = 'üéÆ PUBG Performance Dashboard';
      document.getElementById('lastUpdated').textContent = 'Loading sync information...';
      
      // Remove active state from all player buttons
      document.querySelectorAll('.player-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Reset special buttons
      resetSpecialButtons();
      
      // Clear current player
      currentPlayer = null;
    }

    function updatePlayerBio(playerName) {
      const player = playerData[playerName];
      if (!player) return;
      
      // Update player name
      document.getElementById('bioPlayerName').textContent = playerName;
      
      // Calculate player statistics from full match data
      if (!fullMatchData || fullMatchData.length === 0) {
        document.getElementById('bioContent').innerHTML = player.bio;
        document.getElementById('playerBio').classList.remove('hidden');
        return;
      }
      
      // Filter matches for this specific player
      const playerMatches = fullMatchData.filter(match => 
        match.team && match.team.some(teammate => teammate.name === playerName)
      );
      
      if (playerMatches.length === 0) {
        document.getElementById('bioContent').innerHTML = player.bio;
        document.getElementById('playerBio').classList.remove('hidden');
        return;
      }
      
      // Calculate overall statistics
      let totalKills = 0;
      let totalDamage = 0;
      let totalHeadshots = 0;
      let totalAssists = 0;
      let totalRevives = 0;
      const weaponDamage = {};
      const damagePerMatch = [];
      
      playerMatches.forEach(match => {
        const playerData = match.team.find(p => p.name === playerName);
        if (playerData) {
          totalKills += playerData.kills || 0;
          totalDamage += playerData.damage || 0;
          totalHeadshots += playerData.headshots || 0;
          totalAssists += playerData.assists || 0;
          totalRevives += playerData.revives || 0;
          
          // Track damage per match for chart
          damagePerMatch.push({
            date: match.date,
            damage: playerData.damage || 0
          });
          
          // Aggregate weapon damage
          if (playerData.weaponDamage) {
            Object.entries(playerData.weaponDamage).forEach(([weapon, damage]) => {
              if (weapon.includes('Player') || weapon.includes('Effect')) return;
              const cleanName = cleanWeaponName(weapon);
              if (!weaponDamage[cleanName]) weaponDamage[cleanName] = 0;
              weaponDamage[cleanName] += damage;
            });
          }
        }
      });
      
      // Find top 2 weapons
      const topWeapons = Object.entries(weaponDamage)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
      
      const favoriteWeapon1 = topWeapons[0] ? `${topWeapons[0][0]} (${Math.round(topWeapons[0][1]).toLocaleString()} dmg)` : 'N/A';
      const favoriteWeapon2 = topWeapons[1] ? `${topWeapons[1][0]} (${Math.round(topWeapons[1][1]).toLocaleString()} dmg)` : 'N/A';
      
      // Calculate averages
      const avgKills = (totalKills / playerMatches.length).toFixed(1);
      const avgDamage = Math.round(totalDamage / playerMatches.length);
      
      // Sort matches by date for chart
      damagePerMatch.sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Create dynamic bio content
      const bioHtml = `
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
          <div>
            <h4 style="margin: 0 0 10px 0; color: #667eea;">üìä Career Statistics</h4>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 15px;">
              <p style="margin: 5px 0;"><strong>Total Matches:</strong> ${playerMatches.length}</p>
              <p style="margin: 5px 0;"><strong>Total Kills:</strong> ${totalKills} (avg: ${avgKills})</p>
              <p style="margin: 5px 0;"><strong>Total Damage:</strong> ${Math.round(totalDamage).toLocaleString()} (avg: ${avgDamage.toLocaleString()})</p>
              <p style="margin: 5px 0;"><strong>Total Headshots:</strong> ${totalHeadshots}</p>
              <p style="margin: 5px 0;"><strong>Total Assists:</strong> ${totalAssists}</p>
              <p style="margin: 5px 0;"><strong>Total Revives:</strong> ${totalRevives}</p>
            </div>
          </div>
          
          <div>
            <h4 style="margin: 0 0 10px 0; color: #667eea;">üéØ Favorite Weapons</h4>
            <div style="background: #f8f9fa; border-radius: 8px; padding: 15px;">
              <p style="margin: 5px 0;"><strong>ü•á #1:</strong> ${favoriteWeapon1}</p>
              <p style="margin: 5px 0;"><strong>ü•à #2:</strong> ${favoriteWeapon2}</p>
              <p style="margin: 15px 0 5px 0; font-size: 12px; color: #666;">Based on total damage across all matches</p>
            </div>
            
            <div style="margin-top: 15px;">
              ${player.bio}
            </div>
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <h4 style="margin: 0 0 10px 0; color: #667eea;">üìà Damage Trend (All Matches)</h4>
          <div style="background: white; border-radius: 8px; padding: 15px; height: 250px;">
            <canvas id="playerDamageTrendChart"></canvas>
          </div>
        </div>
      `;
      
      document.getElementById('bioContent').innerHTML = bioHtml;
      document.getElementById('playerBio').classList.remove('hidden');
      
      // Create damage trend chart
      setTimeout(() => {
        const canvas = document.getElementById('playerDamageTrendChart');
        if (!canvas) {
          console.error('Player damage trend canvas not found');
          return;
        }
        
        // Destroy existing chart if any
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
          existingChart.destroy();
        }
        
        new Chart(canvas, {
          type: 'line',
          data: {
            labels: damagePerMatch.map((m, i) => `Match ${i + 1}`),
            datasets: [{
              label: 'Damage per Match',
              data: damagePerMatch.map(m => m.damage),
              borderColor: '#667eea',
              backgroundColor: 'rgba(102, 126, 234, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.3,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top'
              },
              tooltip: {
                callbacks: {
                  title: (items) => {
                    const index = items[0].dataIndex;
                    const matchDate = new Date(damagePerMatch[index].date);
                    return matchDate.toLocaleString('en-GB', {
                      day: '2-digit',
                      month: '2-digit',
                      year: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    });
                  },
                  label: (item) => {
                    return `Damage: ${Math.round(item.parsed.y).toLocaleString()}`;
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Damage'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Match History'
                },
                ticks: {
                  maxTicksLimit: 15
                }
              }
            }
          }
        });
      }, 100);
    }

    async function loadPlayerData(playerName) {
      const player = playerData[playerName];
      if (!player) return;
      
      try {
        console.log(`üìä Loading data for ${playerName}...`);
        
        // Add cache busting with timestamp
        const timestamp = new Date().getTime();
        
        // Try to load player-specific file first, fallback to main data.json
        let response;
        let dataFile = player.dataFile;
        
        try {
          response = await fetch(`${dataFile}?t=${timestamp}`);
          if (!response.ok) throw new Error('Player file not found');
        } catch (error) {
          console.log(`‚ö†Ô∏è Player-specific file not found for ${playerName}, trying main data.json...`);
          dataFile = 'data.json';
          response = await fetch(`${dataFile}?t=${timestamp}`);
          
          if (!response.ok) {
            throw new Error(`Failed to load any data file: ${response.status}`);
          }
        }
        
        const allData = await response.json();
        
        // Always keep the full dataset for global functions (memes, records, changelog)
        fullMatchData = allData;
        
        // Filter data for the specific player if using main data.json
        if (dataFile === 'data.json' && playerName !== 'Kilma9') {
          matchData = allData.filter(match => 
            match.team && match.team.some(teammate => teammate.name === playerName)
          );
          console.log(`‚úÖ Filtered ${matchData.length} matches for ${playerName} from main data`);
        } else {
          matchData = allData;
          console.log(`‚úÖ Loaded ${matchData.length} matches for ${playerName}`);
        }
        
        // Update dashboard title
        document.querySelector('.header h1').textContent = `üéÆ ${playerName}'s PUBG Performance Dashboard`;
        
        // Update sync information
        await updateSyncInfo(matchData);
        
        // Clear cached records to force recalculation with full dataset
        cachedRecords = null;
        
        // Repopulate dropdowns and data
        populateDayDropdown();
        populateTeamCompositions();
        
      } catch (error) {
        console.error(`‚ùå Error loading data for ${playerName}:`, error);
        matchData = [];
        
        // Show error message
        document.getElementById('daySummary').innerHTML = `
          <div class="stat-card">
            <div class="stat-title">No Data Available</div>
            <div class="stat-value">Data for ${playerName} not found or failed to load</div>
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
              Make sure the data collection has been run for this player
            </div>
          </div>
        `;
      }
    }

    // Add event listeners for player buttons
    document.querySelectorAll('.player-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const playerName = btn.dataset.player;
        switchPlayer(playerName);
      });
    });
    
    // Return to dashboard button event listener
    document.getElementById('returnToDashboard').addEventListener('click', function() {
      returnToMainDashboard();
    });

    // Team composition filter event listener
    document.getElementById('teamCompositionSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        // Reset match selection when composition changes
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    // Team size filter event listener
    document.getElementById('teamSizeSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      
      if (selectedDay) {
        populateMatchDropdown(selectedDay);
        showDaySummary(selectedDay);
        document.getElementById('matchSelect').value = '';
        document.getElementById('matchContent').classList.add('hidden');
      }
    });

    document.getElementById('matchSelect').addEventListener('change', function() {
      const selectedDay = document.getElementById('daySelect').value;
      const matchIndex = parseInt(this.value);
      
      console.log('Match selected:', matchIndex, 'for day:', selectedDay);
      
      if (!isNaN(matchIndex) && selectedDay) {
        // Show known bugs section
        const knownBugs = document.getElementById('knownBugs');
        if (knownBugs) knownBugs.style.display = 'block';
        
        // Reset bio and special dropdowns
        const bioSelect = document.getElementById('bioSelect');
        if (bioSelect) bioSelect.value = '';
        resetSpecialButtons();
        document.getElementById('bioContent').classList.add('hidden');
        document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
        
        // Hide day summary when match is selected
        document.getElementById('dayContent').classList.add('hidden');
        
        const teamComposition = document.getElementById('teamCompositionSelect').value;
        const teamSize = document.getElementById('teamSizeSelect').value;
        const dayMatches = getFilteredMatches(selectedDay, teamComposition, teamSize);
        showMatchDetails(dayMatches, matchIndex);
      } else {
        document.getElementById('matchContent').classList.add('hidden');
        // Show day summary again when no match is selected
        if (selectedDay) {
          document.getElementById('dayContent').classList.remove('hidden');
        }
        // Re-destroy only match charts, keep day charts
        const matchCharts = currentCharts.filter(chart => 
          chart.canvas && chart.canvas.id && chart.canvas.id.includes('match')
        );
        matchCharts.forEach(chart => {
          if (chart && typeof chart.destroy === 'function') {
            chart.destroy();
          }
        });
        currentCharts = currentCharts.filter(chart => 
          !(chart.canvas && chart.canvas.id && chart.canvas.id.includes('match'))
        );
      }
    });

    // Function to hide/show main dashboard sections
    function toggleMainDashboard(hide = false) {
      const mainSections = ['dayContent', 'matchContent'];
      const knownBugs = document.getElementById('knownBugs');
      
      if (hide) {
        // Hide main sections when Bio/Special is active
        mainSections.forEach(sectionId => {
          document.getElementById(sectionId).classList.add('hidden');
        });
        if (knownBugs) knownBugs.style.display = 'none';
      } else {
        // Show main sections when returning to normal mode
        mainSections.forEach(sectionId => {
          document.getElementById(sectionId).classList.remove('hidden');
        });
        if (knownBugs) knownBugs.style.display = 'block';
      }
    }

    // BIO dropdown event listener
    const bioSelectEl = document.getElementById('bioSelect');
    if (bioSelectEl) {
      bioSelectEl.addEventListener('change', function() {
        const selectedPlayer = this.value;
        
        console.log('Player BIO selected:', selectedPlayer);
        
        if (selectedPlayer) {
          // Hide main dashboard when showing bio
          toggleMainDashboard(true);
          showPlayerBio(selectedPlayer);
          
          // Reset other dropdowns
          resetSpecialButtons();
          document.getElementById('memeContent').classList.add('hidden');
        document.getElementById('recordsContent').classList.add('hidden');
        document.getElementById('changelogContent').classList.add('hidden');
      } else {
        // Show main dashboard when no bio selected
        toggleMainDashboard(false);
        document.getElementById('bioContent').classList.add('hidden');
      }
    });
    }

    // Helper function to reset special button states
    function resetSpecialButtons() {
      document.querySelectorAll('.special-btn').forEach(btn => {
        btn.classList.remove('active');
      });
    }

    // Helper function to hide all special sections
    function hideAllSpecialSections() {
      document.getElementById('memeContent').classList.add('hidden');
      document.getElementById('recordsContent').classList.add('hidden');
      document.getElementById('changelogContent').classList.add('hidden');
    }

    // Memes button event listener
    document.getElementById('memesBtn').addEventListener('click', function() {
      console.log('Memes button clicked');
      
      // Check if player data is loaded
      if (!fullMatchData || fullMatchData.length === 0) {
        alert('‚ö†Ô∏è Please select a player first!');
        return;
      }
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showMemesDashboard();
      
      // Reset bio dropdown
      const bioSelect = document.getElementById('bioSelect');
      if (bioSelect) bioSelect.value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Records button event listener
    document.getElementById('recordsBtn').addEventListener('click', function() {
      console.log('Records button clicked');
      
      // Check if player data is loaded
      if (!fullMatchData || fullMatchData.length === 0) {
        alert('‚ö†Ô∏è Please select a player first!');
        return;
      }
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showTeamRecords();
      
      // Reset bio dropdown
      const bioSelect = document.getElementById('bioSelect');
      if (bioSelect) bioSelect.value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Changelog button event listener
    document.getElementById('changelogBtn').addEventListener('click', function() {
      console.log('Changelog button clicked');
      
      // Check if player data is loaded
      if (!fullMatchData || fullMatchData.length === 0) {
        alert('‚ö†Ô∏è Please select a player first!');
        return;
      }
      
      // Reset other buttons and hide all sections first
      resetSpecialButtons();
      hideAllSpecialSections();
      
      // Set this button as active
      this.classList.add('active');
      
      // Hide main dashboard when showing special sections
      toggleMainDashboard(true);
      showChangelog();
      
      // Reset bio dropdown
      const bioSelect = document.getElementById('bioSelect');
      if (bioSelect) bioSelect.value = '';
      document.getElementById('bioContent').classList.add('hidden');
    });

    // Function to show player bio
    function showPlayerBio(playerName) {
      const bioData = {
        'Kilma9': {
          description: 'Somehow crashes every vehicle! üöóüí• Maybe stick to ARs instead of SMGs and try DMRs over SRs - your teammates\' ears will thank you!',
          favoriteGun: 'Gliders',
          funnyNote: 'Driving instructor\'s worst nightmare'
        },
        'Veru_13': {
          description: 'The queen of all range engagements who dominates every distance! üëëüéØ AUG for close spraying, Mini14 for long-range sniping - true master of battlefield versatility!',
          favoriteGun: 'AUG & Mini14',
          funnyNote: 'Range? What range?'
        },
        'Mar-0': {
          description: 'The landing strategist who always picks the "perfect" spot... right between 5 enemy teams! ü™ÇüíÄ At least he has an AUG to fight his way out!',
          favoriteGun: 'AUG',
          funnyNote: 'Hot zone magnet'
        },
        'Hyottokko': {
          description: 'Son of ancient Greek gods with divine bloodline... too bad he forgot to bring those powers into PUBG! ‚ö°Ô∏èüèõÔ∏è The gods are still waiting for him to awaken!',
          favoriteGun: 'Kar98k',
          funnyNote: 'Dormant deity'
        },
        'Baron_Frajeris': {
          description: 'The legendary hoarder who carries zero ammo and no heals, but somehow has 200 mortar shells! üí£üéí "Need ammo?" - "Sorry, only explosives!"',
          favoriteGun: 'Mortars',
          funnyNote: 'Explosive logistics expert'
        },
        'codufus': {
          description: 'Bad mother father from the beautiful island of Corsica! üèùÔ∏èüòé Feels right at home on Paramo map - another volcanic island where he can spray enemies among familiar terrain and architecture!',
          favoriteGun: 'AUG',
          funnyNote: 'Volcanic island warrior'
        }
      };

      const player = bioData[playerName] || {
        description: 'Mysterious player with classified intel.',
        favoriteGun: 'Pan',
        funnyNote: 'Identity unknown'
      };

      const bioHtml = `
        <div class="player-bio">
          <h2>üéÆ ${playerName}</h2>
          <div class="bio-content">
            <p>${player.description}</p>
          </div>
          <div class="bio-stats">
            <div class="stat-card">
              <div class="stat-title">Favorite Gun</div>
              <div class="stat-value">üî´ ${player.favoriteGun}</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Status</div>
              <div class="stat-value">Active Player</div>
            </div>
            <div class="stat-card">
              <div class="stat-title">Specialty</div>
              <div class="stat-value">${player.funnyNote}</div>
            </div>
          </div>
        </div>
      `;

      document.getElementById('bioDetails').innerHTML = bioHtml;
      document.getElementById('bioContent').classList.remove('hidden');
    }

    // Function to show Memes Dashboard
    function showMemesDashboard() {
      const memeStats = calculateMemeStats();
      
      const memeHtml = `
        <div class="meme-grid">
          <div class="meme-card">
            <div class="meme-title">üöóüí• Vehicle Destruction Expert</div>
            <div class="meme-value">Kilma9</div>
            <div class="meme-description">"I swear the glider controls are different!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üéí Explosive Hoarder Award</div>
            <div class="meme-value">Baron_Frajeris</div>
            <div class="meme-description">"Need ammo? I have mortars!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">ü™Ç Hot Zone Magnet</div>
            <div class="meme-value">Mar-0</div>
            <div class="meme-description">"This looks like a quiet spot..." *5 teams land*</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">‚ö° Sleeping Deity</div>
            <div class="meme-value">Hyottokko</div>
            <div class="meme-description">"Gods don't need aim assist"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üëë Range Empress</div>
            <div class="meme-value">Veru_13</div>
            <div class="meme-description">"Distance is just a number"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üíä Most Likely to Need Revive</div>
            <div class="meme-value">${memeStats.mostRevives}</div>
            <div class="meme-description">"I was checking the map!"</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üî• Damage Dealer Supreme</div>
            <div class="meme-value">${memeStats.topDamager}</div>
            <div class="meme-description">Making enemies regret their life choices</div>
          </div>
          
          <div class="meme-card">
            <div class="meme-title">üéØ Kill Stealer Extraordinaire</div>
            <div class="meme-value">${memeStats.killStealer}</div>
            <div class="meme-description">"I was helping!"</div>
          </div>
        </div>
      `;
      
      document.getElementById('memeDetails').innerHTML = memeHtml;
      document.getElementById('memeContent').classList.remove('hidden');
    }

    // Function to show Team Records
    function showTeamRecords() {
      // Use cached records if available, otherwise calculate fresh
      const records = cachedRecords || calculateTeamRecords();
      
      if (!cachedRecords) {
        console.log('‚ö†Ô∏è No cached records found, calculating fresh records');
        cachedRecords = records; // Cache for next time
      } else {
        console.log('‚úÖ Using pre-calculated cached records');
      }
      
      const recordsHtml = `
        <div class="records-grid">
          <div class="record-card">
            <div class="record-trophy">üèÜ</div>
            <div class="record-title">Highest Single Match Damage</div>
            <div class="record-holder">${records.topDamage.player}</div>
            <div class="record-value">${records.topDamage.value.toLocaleString()}</div>
            <div class="record-date">üìÖ ${records.topDamage.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üíÄ</div>
            <div class="record-title">Most Kills in One Match</div>
            <div class="record-holder">${records.topKills.player}</div>
            <div class="record-value">${records.topKills.value}</div>
            <div class="record-date">üìÖ ${records.topKills.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üéØ</div>
            <div class="record-title">Best Team Damage Combined</div>
            <div class="record-holder">Team Record</div>
            <div class="record-value">${records.teamDamage.value.toLocaleString()}</div>
            <div class="record-date">üìÖ ${records.teamDamage.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üíä</div>
            <div class="record-title">Most Revives in One Match</div>
            <div class="record-holder">${records.topRevives.player}</div>
            <div class="record-value">${records.topRevives.value}</div>
            <div class="record-date">üìÖ ${records.topRevives.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üè•</div>
            <div class="record-title">Healing Champion</div>
            <div class="record-holder">${records.topHeals.player}</div>
            <div class="record-value">${records.topHeals.value}</div>
            <div class="record-date">üìÖ ${records.topHeals.date}</div>
          </div>
          
          <div class="record-card">
            <div class="record-trophy">üöÄ</div>
            <div class="record-title">Boost Master</div>
            <div class="record-holder">${records.topBoosts.player}</div>
            <div class="record-value">${records.topBoosts.value}</div>
            <div class="record-date">üìÖ ${records.topBoosts.date}</div>
          </div>
        </div>
      `;
      
      document.getElementById('recordsDetails').innerHTML = recordsHtml;
      document.getElementById('recordsContent').classList.remove('hidden');
    }

    // Function to show changelog
    function showChangelog() {
      const changelogHtml = `
        <div style="max-width: 800px; margin: 0 auto;">
          <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #333; margin-top: 0;">üìã PUBG Tracker Development History</h3>
            <p style="color: #666; margin-bottom: 0;">Track the evolution of your favorite PUBG performance dashboard!</p>
          </div>
          
          <div style="border-left: 4px solid #6f42c1; padding-left: 20px; margin-bottom: 30px;">
            <div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="color: #6f42c1; margin: 0;">Version 1.2 - Multi-Player Dashboard üéÆ</h4>
                <span style="background: #6f42c1; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">25.10.2025</span>
              </div>
              <ul style="margin: 10px 0; color: #333;">
                <li><strong>Multi-Player Support:</strong> Dashboard now supports all 6 squad members with individual data files</li>
                <li><strong>Welcome Screen:</strong> Clean first-load experience with quick start guide</li>
                <li><strong>Player Profiles:</strong> Each player has custom icon, role, and bio</li>
                <li><strong>Enhanced Filtering:</strong> Proper team size (solo/duo/squad) and composition filtering</li>
                <li><strong>Improved Layout:</strong> Wider dashboard, BIO section repositioned for better space utilization</li>
                <li><strong>Smart Data Management:</strong> Separate filtered vs global datasets for accurate statistics</li>
                <li><strong>UX Polish:</strong> Daily summary auto-hides when viewing match details</li>
                <li><strong>Bug Fixes:</strong> Fixed team size filtering, null reference errors, and special button validation</li>
              </ul>
              <div style="background: #e7d4f7; border-radius: 4px; padding: 10px; margin-top: 15px;">
                <small style="color: #6f42c1;">
                  <strong>Team Roster:</strong> Now tracking Kilma9, Mar-0, Hyottokko, Baron_Frajeris, codufus, and Veru_13!
                  Each player's stats are collected independently with individual data files.
                </small>
              </div>
            </div>
          </div>
          
          <div style="border-left: 4px solid #e67e22; padding-left: 20px; margin-bottom: 30px;">
            <div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="color: #e67e22; margin: 0;">Version 1.1 üîî</h4>
                <span style="background: #e67e22; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">19.10.2025</span>
              </div>
              <ul style="margin: 10px 0; color: #333;">
                <li><strong>Discord Integration:</strong> Real-time match notifications to Discord channel</li>
                <li><strong>Smart Detection:</strong> Automatic new match detection every 10 minutes</li>
                <li><strong>Rich Notifications:</strong> Performance stats, team composition, and match details</li>
                <li><strong>Duplicate Prevention:</strong> State tracking prevents duplicate notifications</li>
                <li><strong>Enhanced Records:</strong> Automatic record recalculation with every data sync</li>
                <li><strong>UI Improvements:</strong> Separate buttons for special sections, date/time in records</li>
                <li><strong>Real Sync Timestamps:</strong> Display actual GitHub Actions execution time</li>
              </ul>
              <div style="background: #fff3cd; border-radius: 4px; padding: 10px; margin-top: 15px;">
                <small style="color: #856404;">
                  <strong>New Feature Highlight:</strong> Get instant Discord notifications when you finish a PUBG match! 
                  Rich embeds show kills, damage, placement, teammates, and match timing in Prague timezone.
                </small>
              </div>
            </div>
          </div>
          
          <div style="border-left: 4px solid #28a745; padding-left: 20px; margin-bottom: 30px;">
            <div style="background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="color: #28a745; margin: 0;">Version 1.0 üéâ</h4>
                <span style="background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">18.10.2025</span>
              </div>
              <ul style="margin: 10px 0; color: #333;">
                <li><strong>Initial Release:</strong> Complete PUBG performance tracking dashboard</li>
                <li><strong>Core Features:</strong> Daily summaries, match details, weapon analytics</li>
                <li><strong>Team System:</strong> Composition filtering and player statistics</li>
                <li><strong>Player BIOs:</strong> Humorous player profiles with favorite weapons</li>
                <li><strong>Special Sections:</strong> Meme dashboard and team records</li>
                <li><strong>Automation:</strong> Scheduled data collection via GitHub Actions</li>
                <li><strong>Deployment:</strong> Automated CI/CD pipeline to webzdarma.cz hosting</li>
                <li><strong>Cache Management:</strong> Smart data refresh and sync tracking</li>
              </ul>
              <div style="background: #f8f9fa; border-radius: 4px; padding: 10px; margin-top: 15px;">
                <small style="color: #666;">
                  <strong>Technical Stack:</strong> HTML5, JavaScript ES6, Chart.js, Node.js, PUBG API, GitHub Actions
                </small>
              </div>
            </div>
          </div>
          
          <div style="text-align: center; color: #666; font-style: italic;">
            <small>üöÄ Latest: Multi-player dashboard now live! Track all 6 squad members with individual profiles...</small>
          </div>
        </div>
      `;
      
      document.getElementById('changelogDetails').innerHTML = changelogHtml;
      document.getElementById('changelogContent').classList.remove('hidden');
    }

    // Function to calculate meme statistics
    function calculateMemeStats() {
      if (!fullMatchData || fullMatchData.length === 0) {
        return {
          mostRevives: 'Unknown',
          topDamager: 'Unknown',
          killStealer: 'Unknown'
        };
      }

      const playerStats = {};
      fullMatchData.forEach(match => {
        match.team.forEach(player => {
          if (!playerStats[player.name]) {
            playerStats[player.name] = { 
              revives: 0, damage: 0, kills: 0, matches: 0 
            };
          }
          playerStats[player.name].revives += player.revives || 0;
          playerStats[player.name].damage += player.damage || 0;
          playerStats[player.name].kills += player.kills || 0;
          playerStats[player.name].matches++;
        });
      });

      const mostRevives = Object.entries(playerStats)
        .sort((a, b) => b[1].revives - a[1].revives)[0]?.[0] || 'Unknown';
      
      const topDamager = Object.entries(playerStats)
        .sort((a, b) => b[1].damage - a[1].damage)[0]?.[0] || 'Unknown';
      
      const killStealer = Object.entries(playerStats)
        .sort((a, b) => {
          const aRatio = a[1].kills / Math.max(a[1].damage, 1);
          const bRatio = b[1].kills / Math.max(b[1].damage, 1);
          return bRatio - aRatio;
        })[0]?.[0] || 'Unknown';

      return { mostRevives, topDamager, killStealer };
    }

    // Function to calculate team records
    function calculateTeamRecords() {
      if (!fullMatchData || fullMatchData.length === 0) {
        return {
          topDamage: { player: 'Unknown', value: 0, date: 'N/A' },
          topKills: { player: 'Unknown', value: 0, date: 'N/A' },
          teamDamage: { value: 0, date: 'N/A' },
          topRevives: { player: 'Unknown', value: 0, date: 'N/A' },
          topHeals: { player: 'Unknown', value: 0, date: 'N/A' },
          topBoosts: { player: 'Unknown', value: 0, date: 'N/A' }
        };
      }

      let topDamage = { player: '', value: 0, date: '' };
      let topKills = { player: '', value: 0, date: '' };
      let teamDamage = { value: 0, date: '' };
      let topRevives = { player: '', value: 0, date: '' };
      let topHeals = { player: '', value: 0, date: '' };
      let topBoosts = { player: '', value: 0, date: '' };

      fullMatchData.forEach(match => {
        let matchTeamDamage = 0;
        const matchDate = new Date(match.date).toLocaleDateString('en-GB', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        match.team.forEach(player => {
          // Track individual records with dates
          if (player.damage > topDamage.value) {
            topDamage = { player: player.name, value: player.damage, date: matchDate };
          }
          if (player.kills > topKills.value) {
            topKills = { player: player.name, value: player.kills, date: matchDate };
          }
          if (player.revives > topRevives.value) {
            topRevives = { player: player.name, value: player.revives, date: matchDate };
          }
          if (player.heals > topHeals.value) {
            topHeals = { player: player.name, value: player.heals, date: matchDate };
          }
          if (player.boosts > topBoosts.value) {
            topBoosts = { player: player.name, value: player.boosts, date: matchDate };
          }
          
          matchTeamDamage += player.damage || 0;
        });
        
        if (matchTeamDamage > teamDamage.value) {
          teamDamage = { value: matchTeamDamage, date: matchDate };
        }
      });

      return { topDamage, topKills, teamDamage, topRevives, topHeals, topBoosts };
    }
  </script>
</body>
</html>